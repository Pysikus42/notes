#+AUTHOR: Robin Heinemann
#+TITLE: Einführung in die Anwendungsorientierte Informatik (Köthe)

#+INCLUDE: "../header.org" :minlevel 1
#+LATEX_HEADER: \setlistdepth{20}
#+LATEX_HEADER: \renewlist{itemize}{itemize}{20}
#+LATEX_HEADER: \setlist[itemize]{label=$\cdot$}

# #+BEGIN_SRC cpp
# for(int i = 0; i < 5) {
#    std::cout << i << std::endl;
# }
# #+END_SRC

#+INCLUDE: "introduction.org" :minlevel 1
#+INCLUDE: "differences.org" :minlevel 1
#+INCLUDE: "substitution_model.org" :minlevel 1
#+INCLUDE: "machine_code.org" :minlevel 1
#+INCLUDE: "functional_programming.org" :minlevel 1
#+INCLUDE: "procedural_programming.org" :minlevel 1
#+INCLUDE: "datatypes.org" :minlevel 1
#+INCLUDE: "stack_model.org" :minlevel 1
#+INCLUDE: "references.org" :minlevel 1
#+INCLUDE: "container.org" :minlevel 1
#+INCLUDE: "itertators.org" :minlevel 1

* Insertion Sort
  schnellster Sortieralgorithmus für kleine Arrays ($n\leq 30$) hängt von Compiler und CPU ab
  - Idee von Insertion Sort:
	- wie beim Aufnehmen und Ordnen eines Kartenblatts
	- gegeben: bereits sortierte Teilmenge bis Position $k - 1$ Karten bereits in Fächer
	- Einfügen des k-ten Elements an richtiger Stelle \rightarrow Erzeuge Lücke an richtiger Position durch verschieben von Elementen nach rechts
	- Wiederholung für $k = 1, \ldots, N$
	- Beispiel:
	  | 4 | 2 | 3 | 5 | 1 |
	  |---+---+---+---+---|
	  | 4 | _ | 3 | 5 | 1 |
	  | _ | 4 | 3 | 5 | 1 |
	  | 2 | 4 | 3 | 5 | 1 |
	  |---+---+---+---+---|
	  | 2 | 4 | _ | 5 | 1 |
	  | 2 | _ | 4 | 5 | 1 |
	  | 2 | 3 | 4 | 5 | 1 |
	  |---+---+---+---+---|
	  | 2 | 3 | 4 | _ | 1 |
	  | 2 | 3 | 4 | 5 | 1 |
	  |---+---+---+---+---|
	  | 2 | 3 | 4 | 5 | _ |
	  | _ | 2 | 3 | 4 | 5 |
	  | 1 | 2 | 3 | 4 | 5 |
	  #+BEGIN_SRC cpp
	  void insertion_sort(std::vector<double> & v) {
		  for(int i = 0; i < v.size(); i++) {
			  double current = v[i];
			  int j = i; // Anfangsposition der Lücke
			  while(j > 0) {
				  if(v[j - 1] < current) { // -> if(cmp(a, b))
					  break; // j ist richtige Position der Lücke
				  }
				  v[j] = v[j - 1];
				  j--;
			  }
			  v[j] = current;
		  }
	  }
	  #+END_SRC
	- andere Sortierung: definiere Funktor cmp(a, b), der das gewünschte kleiner realisiert (gibt genau dann "true" zurück, wenn a "kleiner" b nach neuer Sortierung)
	- neue Sortierung am besten per Lambda-Funktion an std::sort übergeben
	  #+BEGIN_SRC cpp
	  std::sort(v.begin(), v.end()); // Standartsort mit "<"
	  std::sort(v.begin(), v.end(), [](double a, double b) { return a < b; }); // Standardsortierung aufsteigen
	  std::sort(v.begin(), v.end(), [](double a, double b) { return b < a; }); // absteigende Sortierung
	  std::sort(v.begin(), v.end(), [](double a, double b) { return std::abs(a) < std::abs(b); }); // Normal nach Betrag; // Normal nach Betrag
	  std::sort(v.begin(), v.end(), [](std::string a, std::string b) {
		  std::transform(a.begin(), a.end(), a.begin(), std::tolower);
		  std::transform(b.begin(), b.end(), b.begin(), std::tolower);
		  return a < b;
	  });
	  #+END_SRC
* generische Programmierung
  insertion_sort soll für beliebige Elementtypen funktionieren
  #+BEGIN_SRC cpp
	  template<typename T>
	  void insertion_sort(std::vector<T> & v) {
		  for(int i = 0; i < v.size(); i++) {
			  T current = v[i];
			  int j = i; // Anfangsposition der Lücke
			  while(j > 0) {
				  if(v[j - 1] < current) { // -> if(cmp(a, b))
					  break; // j ist richtige Position der Lücke
				  }
				  v[j] = v[j - 1];
				  j--;
			  }
			  v[j] = current;
		  }
	  }
  #+END_SRC
  - Ziel: benutze template-Mechanismus, damit *eine* Implementation für viele verschiedene Typen verwendbar ist
	- erweitert funktionale und prozedurale und objekt-orientiere Programmierung
  - zwei Arten von Templates ("Schablone"):
	1. Klassen-templates für Datenstrukturen, zum Beispiel Container sollen beliebige Elementtypen unterstützen
	   - Implementation $\implies$ später
	   - Benutzung: Datenstrukturname gefolgt vom Elementtyp in spitzen Klammern (std::vector<double>), oder mehrere Typen, zum Beispiel Schlüssel und Wert bei std::map<std::string, double>
	2. Funktionen-Templates: es gab schon function overloading
	   #+BEGIN_SRC cpp
	   int sq(int x) {
		   return x * x;
	   }

	   double sq(double x) {
		  return x * x;
	   }

	   // und so weiter für komplexe und rationale Zahlen...
	   #+END_SRC
	   - Nachteil
		 - wenn die Implementationen gleich sind \rightarrow nutzlose Arbeit
		 - Redundanz ist gefährlich: korrigiert man einen Bug wir leicht eine Variante vergessen
	   - mit templates reicht eine Implementation
		 #+BEGIN_SRC cpp
		 template<typename T> // T: Platzhalter für beliebigen Typ, wird später durch einen tatsächlichen Typ ersetzt
		 T sq(T x) {
			 return x * x; // implizierte Anforderung an den Typ T, er muss Multiplikation unterstützen, sonst: Fehlermeldung
		 }
		 #+END_SRC
		 - wie bei Substituieren von Variablen mit Werten, aber jetzt mit Typen
		 - Benutzung:
		   - Typen für die Platzhalter hinter dem Funktionsnamen in spitzen klammern
			 #+BEGIN_SRC cpp
			 sq<int>(2) == 4;
			 sq<double>(3.0) == 9.0,
			 #+END_SRC
		   - meist kann man die Typenangabe <type> weglassen, weil der Computer sie anhand des Argumenttyps automatisch einsetzt:
			 #+BEGIN_SRC cpp
			 sq(2); // == sq<int>(2) == 4
			 sq(3.0); // == sq<double>(3.0) == 9
			 #+END_SRC
		   - kombiniert man templates mit Overloading, wird die ausprogrammierte Variante vom Compiler bevorzugt.
			 Komplizierte Fälle (Argument teilweise Template, teilweise hard_coded) $\implies$ für Fortgeschrittene
		 - Beispiel 2: Funktion, die ein Array auf Konsole ausgibt, für beliebige Elementtypen
		   #+BEGIN_SRC cpp
		   template<typename ElementType>
		   void print_vector(std::vector<ElementType> const & v) {
			   std::cout << "{";
			   if(v.size() > 0) {
				   std::cout << " " << v[0];
				   for(int i = 1; i < v.size(); i++) {
					   std::cout << ", " << v[i];
				   }
			   }
			   std::cout << " }";
		   }
		   #+END_SRC
		 - Verallgemeinerung für beliebige Container mittels Iteratoren:
		   #+BEGIN_SRC cpp
		   std::list<int> l = {1, 2, 3};
		   print_container(l.begin(), l.end()); // "{1,2,3}"
		   #+END_SRC
		 - es genügen forward_itertators
		   #+BEGIN_SRC cpp
		   Iterator iter2 = iter1; // Kopie erzeugen
		   iter1++; // zum nächsten Element
		   iter1 == iter2; // Zeigen sie auf das selbe Element?
		   iter1 != end;
		   *iter1; // Zugriff auf aktuelles Element

		   template<typename Iterator>
		   void print_container(Iterator begin, Iterator end) {
			   std::cout << "{}";
			   if(begin != end) { // Container nicht leer?
				   std::cout << " " << *begin++;
				   for(;begin != end; begin++) {
					   std::cout << ", " << *begin;
				   }
			   std::cout << "}";
		   }
		   #+END_SRC
		 - Beispiel 3: überprüfen, ob Container sortiert ist
		   #+BEGIN_SRC cpp
		   template<typename E, typename CMP>
		   bool check_sorted(std::vector<E> const & v, CMP less_than) {
			   for(int i = 1; i < v.size(); i++) {
				   if(less_than(v[k], v[k - 1])) { // statt v[k] < v[k - 1], ausnutzen der Transitivität
					   return false;
				   }
			   }
			   return true;
		   }

		   // Aufruf:
		   std::vector<double> v = {1.0, 2.0, 3.0};
		   check_sorted(v, [](double a, double b) { return a < b; } ); // == true

		   check_sorted(v, [](double a, double b) { return a > b; } ); // == false

		   // Implementation für Iteratoren
		   template<typename Iterator, typename CMP>
		   bool check_sorted(Iterator begin, Iterator end, CMP less_than) {
			   if(begin == end) {
				   return true;
			   }
			   Iterator next = begin;
			   ++next;
			   for(; next != end; ++begin, ++next) {
				   if(less_than(*next, *begin)) {
					   return false;
				   }
			   }
			   return true;
		   }
		   // == std::is_sorted
		   #+END_SRC
		 - Bemerkung: Compiler-Fehlermeldungen bei Template-Code sind oft schwer zu interpretieren, $\implies$ Erfahrung nötig aber: Compiler werden darin immer besser, besonders clang-Compiler
		 - mit Templates kann man noch viel raffinierter Dinge machen, zum Beispiel Traits-Klassen, intelligent libraries template meta programming $\implies$ nur für Fortgeschrittene
* Effizienz von Algorithmen und Datenstrukturen
** Bestimmung der Effizienz
   2 Möglichkeiten:
   1. Messe die "wall clock time" - wie lange muss man auf das Ergebnis warten
   2. unabhängig von Hardware benutzt man das Konzept der algorithmischen Komplexität
*** wall clock
   wall clock time misst man zum Beispiel mit dem Modul <chrono>
   #+BEGIN_SRC cpp
   #include <chrono>
   #include <iostream>

   int main() {
	   // alles zur Zeitmessung vorbereiten

	   auto start = std::chrono::high_resolution_clock::now(); // Startzeit
	   // code der gemessen werden soll
	   auto stop = std::chrono::high_resolution_clock::now();
	   std::chrono::duration<double> diff = stop - start; // Zeitdifferenz
	   std::cout << "Zeitdauer: " << diff.count() << " Sekunden\n" << std::endl; // ausgeben
   }
   #+END_SRC
   Pitfalls:
   - moderne Compiler optimieren oft zu gut, das heißt komplexe Berechnungen werden zur Compilezeit ausgeführt und ersetzt $\implies$ gemessene Zeit ist viel zu kurz.
	 Abhilfen:
	 - Daten nicht "hard-wired", sondern zum Beispiel von Platte lesen
	 - "volatile" Schlüsselwort "volatile int k = 3;"
   - der Algorithmus ist schneller als die clock $\implies$ rufe den Algorithmus mehrmals in einer Schleife
	 auf
   - die Ausführung ihres Programms kann vom Betriebssystem jederzeit für etwas wichtigeres unterbrochen werden
	 (zum Beispiel Mail checken) $\implies$ gemessene Zeit zu lang $\implies$ messe
	 mehrmals und nimm die kürzeste Zeit (meist reicht 3 bis 10 fach)
   - Faustregel: Messung zwischen $\SI{0.02}{\second}$ und $\SI{3}{\second}$
   Nachteil: Zeit hängt von der Qualität der Implementation, den Daten (insbesondere der Menge) und der Hardware ab
*** algorithmische Komplexität
	Algorithmische Komplexität ist davon unabhängig, ist eine Art theoretisches Effizienzmaß. Sie
	beschreibt, wie sich die Laufzeit verlängert, wenn man mehr Daten hat.

	#+begin_ex latex
	Algorithmus braucht für $n$ Elemente $x$ Sekunden, wie lange dauert es für $2n$, $10n$ für große $n$
	#+end_ex
	Bei effiziente Algorithmen steigt der Aufwand mit $n$ nur langsam (oder bestenfalls gar nicht) \\
	Grundidee:
	1. berechne, wie viele elementare Schritte der Algorithmus in Abhängigkeit von $n$ benötigt $\implies$ komplizierte Formel $f(n)$
	2. vereinfache $f(n)$ in eine einfache Formel $g(n)$, die dasselbe wesentliche Verhalten hat. Die Vereinfachung erfolgt mittels *$O$-Notation* und ihren Verwandten
	   Gegeben: $f(n)$ und $g(n)$
	   1. $g(n)$ ist eine asymptotische (für große $n$) obere Schranke für $f(n)$ ("f(n) \leq g(n)"), $f(n) \in O(g(n))$ "$f(n)$ ist in der Komplexitätsklasse $g(n)$", wenn es ein $n_0$ (Mindestgröße) gibt
		  und $C$ (Konstante) gibt, sodass $\Forall n > n_0: f(n) \leq C g(n) \iff f(n) \in O(g(n))$
	   2. $g(n)$ ist asymptotische untere Schranke für $f(n)$ ($f(n) \geq g(n)$)
		  \[f(n) \in \Omega(g(n)) \iff \Exists n_0,C : \Forall n > n_0 f(n) \geq C g(n)\]
	   3. $g(n)$ ist asymptotisch scharfe Schranke für $f(n) (f(n) = g(n))$
		  \[f(n) \in \Theta(g(n)) \iff f(n) \in O(g(n)) \wedge f(n) \in \Omega(g(n))\]
	Regeln:
	1. $f(n) \in \Theta(f(n)) \implies f(n) \in O(f(n)), f(n) \in \Omega(f(n))$
	2. $c' f(n) \in \Theta(f(n))$
	3. $O(f(n)) \cdot O(g(n)) \in O(f(n) g(n))$ \hfill Multiplikationsregel
	4. $O(f(n)) + O(g(n)) \in O(\text{"`max"'}(f(n), g(n)))$ \hfill Additionsregel \\
	   formal: wenn $f(n) \in O(g(n)) \implies O(f(n)) + O(g(n)) \in O(g(n))$ \\
	   $g(n) \in O(f(n)) \implies O(f(n)) + O(g(n)) \in O(f(n))$
	5. $n^p \in O(n^q)$ wenn $p \leq q$
	Beliebte Wahl für $g(n)$
	- $O(1)$ \hfill "konstante Komplexität" \\
	  elementare Operation "+, -, *, /", Array-Zugriff v[k] (v: std::vector)
	- $O(\log(n))$ \hfill "logarithmische Komplexität" \\
	  zum Beispiel: auf Element von std::map zugreifen m[k] (m: std::map)
	- $O(n)$ \hfill "lineare Komplexität" \\
	  zum Beispiel std::transform() ($n$ = Anzahl der transformierten Elemente)
	- $O(n \log(n))$ \hfill{"`n log n"', "`log linear"' "`linearithmisch"'} \\
	  Beispiel: std::sort
	- $O(n^2)$ \hfill "quadratische Komplexität"
	- $O(n^p)$ \hfill "polynomielle Komplexität"
	- $O(2^n)$ \hfill "exponentielle Komplexität"
	#+begin_ex latex
	\[f(n) = 1 + 15 n + 4n^2 + 7n^3 \in O(n^3)\]
	#+end_ex
*** Anwendung
	1. Fibonacci-Zahlen: $f_k = f_{k - 2} + f_{k - 1}$
	   | k     | 0 | 1 | 2 | 3 | 4 | 5 | 6 |  7 |  8 |
	   |-------+---+---+---+---+---+---+---+----+----|
	   | $f_k$ | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 |
	   #+begin_src cpp
	   int fib1(int k) {
		   if(k < 2) { // O(1)
			   return k; // O(1)
		   }
		   // O(1)
		   int f1 = 0; // letzten beiden Fibonacci Zahlen, anfangs die ersten beiden
		   int f2 = 1;
		   for(int i = 2; i <= k; i++) { // f(k) = k - 1 e O(k)
			   int f = f1 + f2; // O(1)
			   f1 = f2; // O(1)
			   f2 = f; // O(1)
		   } // gesamte Schleife: O(1)*O(k) = O(k)
		   return f2;
	   } // gesamte Funktion: teuerstes gewinnt: O(k)

	   // rekursive Variante:
	   int fib2(int k) {
		   if(k < 2) { // O(1)
			   return k; // O(1)
		   }
		   return fib2(k - 2) + fib2(k - 1);
	   }
	   #+end_src
	   - sehr ineffizient, weil alle Fibonacci-Zahlen $< k$  mehrmals berechnet werden
	   Sei $f(k)$  die Anzahl der Schritte, $f'(k)$ die Schritte oberhalb, Annahme: jeder Knoten ist $O(1) \implies f(k) \in O(\text{Anzahl Knoten})$.
	   Oberhalb ist der Baum vollständig (jeder nnere Knoten hat zwei Kinder), Anzahl der Knoten im vollständigen Baum der Tielfe $l$:
	   \[1 + 2 + 4 + \ldots + 2^l = 2^{l + 1} - 1\]
* Zahlendarstellung im Computer
  Problem: es gibt $\infty$ viele Zahlen, aber der Computer ist endlich.
** Natürliche Zahlen
   Natürliche Zahlen $\implies x \geq 0$. c++ bietet Typen verschiederne Größe.
   | klassisch          | mit Größe | Anzahl Bits | Bereich                | Literale |
   |--------------------+-----------+-------------+------------------------+----------|
   | unsigned char      | uint8_t   | ($\geq$) 8  | 0 - 255                |          |
   | unsigned short     | uint16_t  | ($\geq$) 16 | 0 - 65535              |          |
   | unsigned int       | uint32_t  | ($\geq$) 32 | 0 - $\SI{4e9}{}$       |          |
   | unsigned long      |           | 32 oder 64  |                        |          |
   | unsigned long long | uint64_t  | 64          | 0 - 0 -  $\SI{2e19}{}$ | L        |
   was passiert bei zu großen Zahlen? \\
   - alle Operationen werden Modula $2^m$ ausgeführt, wenn der Typ $m$ Bits hat
	 #+begin_src cpp
	 uint8_t x = 250, y = 100;
	 uint8_t s = x + y; // 350 % 256 = 94
	 uint8_t p = x * y; // 25000 % 256 = 168
	 #+end_src
   "integer overflow": einfach Bits oberhalb von $m$ wegwerfen
*** Pitfalls
	#+begin_src cpp
	std::vector<uint8_t> v = { ... };
	uint8_t sum = 0; // FALSCH, da es zu overflow kommen kann
	// verwende uint32_t, uint64_t, verhndern overflow mit hoher Wahrscheinlichkeit
	for(int k = 0; k < v.size(); k++) {
		sum += v[k];
	}

	// Endlosschleife, da i nie < 0, da unsigned
	// Abhilfe: int verwenden
	for(uint8_t i = v.size(); i >= 0; i++) {
		// auf v[k] zugreifen
	}
	#+end_src
*** arithmetische Operationen
	- Addition in Kapitel Automaten \\
**** Subtraktion
	 Subtraktion kann auf Addition zurückgeführt werden
	 Erinnerung: Restklassenarithmetik: (Modulo) \\
	 alle Zahlen mit dem gleichen Rest modulo $k$ bilden "Äquivalenzklasse", zum Beispiel $k = 4$
	 \begin{align*}
	 0 \mod 4 &= 0 \equiv 4 \mod 4 \equiv 8 \mod 4 \equiv 12 \mod 4 \ldots \\
	 1 \mod 4 &= 1 \equiv 5 \mod 4 \equiv 9 \mod 4 \equiv 13 \mod 4 \ldots \\
	 2 \mod 4 &= 2 \equiv 6 \mod 4 \equiv 10 \mod 4 \equiv 14 \mod 4 \ldots \\
	 3 \mod 4 &= 3 \equiv 7 \mod 4 \equiv 11 \mod 4 \equiv 15 \mod 4 \ldots \\
	 \end{align*}
	 Ein Mitglied jeder Äquivalentzklasse wird Represäntant. \\
	 Hier: kleinste Repreäsentanten $0, \ldots, (k - 1)$, mit $k = 2^m$
	 sind das gerade die uint-Werte \\
	 Eigenschaft: man kann Vielfache $n k$ addieren, ohne Äquivalenzklase zu ändern: \\
	 \[ (a - b) \mod 2^m = (a + \underbrace{2^m - b}_{\mathclap{z:~\text{Zweierkomplement}}}) \mod 2^m = (a + z) \mod 2^m \]
	 $z = (2^m - b) \mod 2^m$ lässt sich billig berechnen als $(\sim b + 1) \mod 2^m$
	 Dabei ist $\sim$ bitweise Negation (dreht alle Bits um)
	 - $m = 4, \sim(1001) = 0110$
	 #+begin_thm latex
	 \[(2^m - b) \mod 2^m = (\sim b + 1) \mod 2^m\]
	 #+end_thm
	 #+begin_proof latex
	 \begin{align*}
	 b + \sim b &= 1111\ldots 1 = 2^m - 1 \\
	 \sim b + 1 &= 2^{m} - b \\
	 \intertext{Fall 1: $b > 0$}
	 \implies \sim b &< 2^m - 1 \implies \sim b + 1 < 2^m \implies (\sim b + 1) \mod 2^m = \sim b + 1 \\
	 \implies (\sim b + 1) \mod 2^m &= (2^m - b) \mod 2^m \\
	 \intertext{Fall 2: $b = 0$}
	 \implies \sim b &= 2^m - 1 \\
	 \sim b + 1 &= 2^m \\
	 \ (\sim b + 1) \mod 2^m &= 0 \\
	 2^m - b &= 2^m \\
	 z &= (2^m - b) \mod 2^m = (\sim b + 1) \mod 2^m = 0
	 \end{align*}
	 #+end_proof
**** Multiplikation
	 Neue Operationen: $\ll$  und $\gg$ (left und right shift). Verschiebt die Bits um $k$ Positionen nach
	 links oder rechts. Die herausgeschobenen Bits werden vergessen und auf der anderen Seite durch
	 $0$-bits ersetzt.

	 #+begin_src cpp
	 // m = 8
	 assert(11011101b << 3 == 11101000b)
	 assert(11011101b >> 3 == 00011011b)
	 #+end_src
	 #+begin_thm latex
	 \begin{align*}
	 x \ll k \equiv (x \cdot 2^k) \mod 2^m \\
	 x >> k \equiv (\frac{x}{2^k}) \\
	 \end{align*}
	 #+end_thm
	 Operation \amp und |: bitw4eise und beziehungsweise oder-Verknüpfung (nicht verwechseln mit \amp\amp und || füür logische Operationen)
	 m = 8:
	 $10110011 \amp 1 = $
	 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
	 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
	 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
	 (testet, ob in linker Zahl Bit 0 gesetzt ist)
	 $10110011 \mid 1 =$
	 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
	 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
	 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
	 kombiniere \amp mit $\ll$:
	 \[x \& (1 \ll k)\]
	 testet, ob in $x$ Bit $k$ gesetzt ist.
	 #+begin_src cpp
	 uint8_t mul(uint8_t x, uint8_t y) {
		  uint8_t res = 0;
		  for(int i = 0; i < 8; i++) {
			   if(y & (1 << i)) {
					res += x;
			   }
			   x = x << 1; // x * 2
		  }
	 }
	 #+end_src
** Ganze Zahlen
   | klassisch        | mit Größe | Anzahl Bits | Bereich               |
   |------------------+-----------+-------------+-----------------------|
   | signed char      | int8_t    |           8 | -128 \ldots 127       |
   | signed short     | int16_t   |          16 | -2^15 \ldots 2^15 - 1 |
   | signed int       | int32_t   |          32 | -2^31 \ldots 2^31 - 2 |
   | signed long      |           |  32 oder 64 |                       |
   | signed long long | int64_t   |          64 | -2^63 \ldots 2^63 - 1 |
   Wird der erlaubte Bereich überschritte, ist Verhalten Compiler abhängig.
   In der Praxis: auch Modulo $2^m$, aber mit anderen Repräsentanten.


   für Restklassen: \\
   statt $0\ldots 2^m$ bei unsigned jetzt $-2^{m - 1} \ldots 2^{m - 2} - 1$ \\
   das heißt:
   - $x < 2^{m - 1}$: Repräsentant bleibt
   - $x \geq 2^{m - 1}$: neuer Represenant $x - 2^{m}$ ist gleiche Restklasse
   Vorteil: $x, -, *$ kann von unsigned übernommen werden \\
   $a,b$ signed: $a$ OP $b$ \to $c$ signed
   (interpretiere Bitmuster von $a$ und $b$ als unsigned und Interpretiere das Ergebnis dann als signed)
  Konsequenzen:
   - bei negativer Zahl ist höchstes Bit 1, weil $x \to x - 2^m$ falls $x \geq 2^{m - 1}$
   - unäre Negation $-x$ duch Zweierkomplement
	 \begin{align*}
	 -x &= (\sim x + 1) \mod 2^m \\
	 -0 &= (\sim 00000000 + 1) \mod 2^8 \\
	 &= (11111111 + 1) \mod 2^8 \\
	 &= \underbrace{(100000000)}_{2^8} \mod 2^8 = 0
	 -1 &= (\sim 00000001 + 1) \mod 2^8 \\
	 &= (11111110 + 1) \mod 2^8 \\
	 &= \underbrace{(11111111)}_{2^8 - 1 < 2^8} \mod 2^8 \\
	 &= 11111111
	 \end{align*}
   Ausnahmeregel für $\gg$ bei negativen Zahlen: Compilerabhängig, meist wird links
   ein 1-Bit reingeschoben, damit Zahl negativ bleibt $\implies$ es gilt immer noch $x \gg k = (x / 2^k)$
   Reichen 64 Bit nicht aus (zum Beispiel bei moderner Verschlüsselung) verwende BigInt: Datentyp variabler Größe.
   Zum Beispiel GNU Multi-Precision Library
** reelle Zahlen
   c++ bietet Typen
   | Name        | Größe                          | Bereich                        | kleinste Zahl   | Literale  |
   |-------------+--------------------------------+--------------------------------+-----------------+-----------|
   | float       | 32bit                          | $\SI{-1e38}{} - \SI{1e38}{}$   | $10e-38$        | 4.0f      |
   | double      | 64bit                          | $\SI{-1e308}{} - \SI{1e308}{}$ | $\SI{1e-308}{}$ | 4.0, 1e-2 |
   | long double | platformabhängig, $\geq$ 64bit |                                |                 |           |
   Der c++ Standard legt die Größe nicht fest, aber praktisch alle gängigen CPUs benutzen Standard IEEE 754, c++
   übernimmt HW-Implementation. Ziele der Definition von reellwertigen Typen:
   - hohe Genauigkeit (viele gültige Nachommastellen)
   - Zahlen sehr unterschiedlicher Größenskalen (zum Beispiel Durchmesser eines Proton $=\SI{2e-15}{\meter}$ vs. Durchmesser des sichtbaren Universum $\SI{1e27}{\meter}$)
	 mit natürlichen Zahlen bräuchte man $> 150$bit
   elegante Lösung: halb-logarithmische Darstellung ("floating point"). Datentyp ist aus 3 natürlichen Zahlen zusammengesetz (aber alles von der CPU gekapselt)
   - $S$ (1-bit): Vorzeichen, 0 = "$+$", 1 = "-"
   - $M$ (m-bit): Mantisse: Nachkommastellen
   - $E$: (e-bit, Bias b): Exponent: Größenordung
   die eigentliche Zahl wird durch
   \[x = (-1)^s \cdot (1 + M\cdot 2^{-m}) \cdot 2^{E-b}\]
   - $M\cdot 2^{-m} \in [0, \frac{2^m - 1}{2^m}\string) \in [0,1\string)$
   - $M \in [0, 2^m - 1]$
   - $1 + M\cdot 2^{-m} \in [1,2\string)$
   Beispiel: natürliche Zahlen
   | $x$ | $M\cdot 2^{-m}$ | $E - b$ | effektive Darstellung |
   |-----+-----------------+---------+-----------------------|
   |   1 |               0 |       0 | $1\cdot 2^0$          |
   |   2 |               0 |       1 | $1\cdot 2^1$          |
   |   3 |             0.5 |       1 | $1.5\cdot 2^1$        |
   |   4 |               0 |       2 | $1\cdot 2^2$          |
   |   5 |            0.25 |       2 | $1.25\cdot 2^2$       |
   Konsequenz: alle ganzen Zahlen zwischen $-2^m, \ldots, 2^m$ könne exakt dargestellt werden und haben exakte Arithmetik. (IEEE 754)
   Werte für $m,e,b$
   - float
	 - $m = 23$
	 - $e = 8$
	 - $b = 127$
	 - $2^{E - b} \in [2^{-126}, 2^{127}] \approx [10^{-38}, 10^{38}]$
   - double
	 - $m = 52$
	 - $e = 11$
	 - $b = 1024$
	 - $2^{E - b} \in [2^{-1022}, 2^{1023}] \approx [10^{-308}, 10^{308}]$
   Anzahl der Nachkommastellen: $\eps = 2^{-m}$ (machine epsilon, unit last place (ULP))
   - float $2^{-23} \approx \SI{1e-7}{}$
   - double $2^{-52} \approx \SI{1e-16}{}$
   $\eps$ ist die kleinste Zahl, sodass
   \[(1.0 + \eps) \neq 1.0\]
   weil Nachkommastellen außerhalb der Mantisse (rechts von $2^{-m}$) ignoriert werden. $\implies$ Problem der Auslöschung von signifikanten Stellen. Wenn man zwei
   fast gleich große Zahlen subtrahiert, löschen sich fast alle Bits der Mantisse $\implies$ nur wenige gültige Nachkommastellen überleben. Zum Beispiel:
   \[0.1234567 - 0.1234566 = 0.000001\tag{nur eine gültige Nachkommastelle!}\]
   \[1.0 - \cos{x}, x \to 0, x\approx 0 \implies \cos{x} \approx 1 \tag*{$\implies$ Auslösung}\]
   | x            | Anzahl der gültigen Stellen | Additionstheoriem $1 - \cos(x) = 2(\sin(x / 2))^2$ |
   |--------------+-----------------------------+----------------------------------------------------|
   | \SI{0.001}{} | 9                           |                                                 15 |
   | \SI{1e-8}{}  | 0 (\cos(\SI{1e-8}{}))       |                                                 15 |
   Quadratische Gleichung:
   \[a x^2 + b x + c = 0, b > 0\]
   \[x_1 = \frac{1}{2 a}(-b + sqrt{b^2 - 4ac})\]
   falls $a\cdot c\wedge b^2 \gg 4ac \implies \sqrt{b^2 -4ac} \approx b \implies x_1 \approx -b + b + (\eps') \approx 0 \implies$ Auslöschung, wenig gültige Stellen. Also umstellen:
   \begin{align*}
   x_1 %= \frac{1}{2a}(-b + \sqrt{b^2 - 4ac}) \frac{-b - \sqrt{b^2 - 4ac}}{-b - \sqrt{b^2 - 4ac}} \\
   &= \frac{1}{2a} \frac{b^2 - (b^2 - 4ac)}{-b - sqrt{b^2 - 4ac}} \\
   &= \frac{2c}{\underbrace{-b -\underbrace{\sqrt{b^2 - 4ac}}_{\approx b}}_{\approx -2b}}
   \intertext{$\implies$ keine Auslösung}
   \intertext{Dies tritt auch bei Aufgabe 8.3 der Übungszettel auf}
   \end{align*}
   Ausnahmeregeln (spezielle Werte)
   - normal: $E\in [1,2^e - 2]$
   - $E = 2^e - 1$ (größtmöglicher Wert): $\begin{cases} x = -\infty & M = 0 \wedge S = 1 \\ x = \infty & M = 0 \wedge S = 0 \\ x = ~\text{NaN}~ & M = 0\end{cases}$
	 - $\pm\infty: \frac{1.0}{0.0}, \frac{-1.0}{0.0}, \ldots$
	 - NaN: $\frac{0.0}{0.0}, \sqrt{-1.0}, \infty\cdot 0$
   - $E = 0$ (kleinstmöglicher Wert): $\begin{cases} -0 & M = 0 \wedge S = 1 \\ 0 & M = 0 \wedge S = 0 \\ \text{denormalisierte Zahlen (für sehr kleine Werte)} & M > 0 \end{cases}$
* Buchstabenzeichen
  Buchstabenzeichen: "glyphs" müssen durch Zahlen repräsentiert werden "Zeichencode"
** Geschichte
   #+ATTR_LATEX: :environment longtable :align l|l|p{2.5cm}|p{7cm}
   | 1963                | ASCII   | 7-bit                                  | Zeichen der englischen Schreibmaschiene (*keine* Umlaute)                                                                                                                                                                                                                                      |
   | 1964 $\ldots$ 2000  |         | 8-bit Codes                            | mit Umlauten, Akzenten, kyrillische Zeichen, aber 8-bit sind zu wenig, um alles abzudecken $\implies$ viele verschiedene 8-bit Codes: DOS Codepage 437, Codepage 850 (Konsole im deutschen Windows), Windows-1252 ("ANSI") $\approx$ ISO 8859-1 \approx ISO 8859.15 (Westeuropäische Sprachen) |
   | 1991 $\ldots$ heute | Unicode | anfangs 16-bit, jetzt $\approx$ 21-bit | alles (chinesisch, Hyroglyphen, Emojis, $\ldots$)                                                                                                                                                                                                                                              |
   3 Codierungen für Unicode:
   - UTF-8: variable length code: pro glyph $1 \ldots 4$ uint8
   - UTF-16: variable length code: pro glyph $1 \ldots 2$ uint16
   - UTF-32: fixed length code: pro glyph 1 uint32 pro glyph
   In c++:
   - char: 8-bit Codes
   - wchar_t: 16-bit (Windows), 32-bit (Linux)
   - u16char_t, u32char_t:
   leider sehr Plattformabhängig
   | Symbol | DOS | ANSI | UTF-8       |
   |--------+-----+------+-------------|
   | ö      | 148 |  246 | 195 182     |
   | €      | 221 |  128 | 226 130 172 |
   $\implies$ ICU Library. \\
   hat man alle Zeichen korrekt, ist Problem noch nicht gelöst: alphabetische Sortierung:
   - kontext abhängig
   - sprach abhängig
   - $ä$:
	 - deutschen Wörterbuch: wie a
	 - deutsches Telefonbuch: wie ae
	 - schwedisch: hinter Zeichen $\overset{\scriptstyle \circ}{a}$
   #+BEGIN_SRC cpp
   #include <locale>
   #include <codecvt
   std::sort(v.begin(), v.end(), std::locale("se_SE.UTF-8")); // für schwedisch (falls se_SE.UTF-8 installiert)
   #+END_SRC
* Eigene Datentypen
  3 Möglichkeiten
  - enum: Aufzählungstypen $\implies$ Selbststudium
  - struct: strukturierte Daten, zusammengesetzte Typen
  - class: wie struct, auf objekt-orientiert
  struct und enum schon in C, struct und class fast gleich
  #+BEGIN_SRC cpp
  struct TypeName { // Neuer Typ
	  type_name1 var_name1; // existierende Typen
	  type_name2 var_name2;
	  // ...
  }; // semikolon WICHTIG, falls vergessen: Fehlermeldung

  // Beispiel:
  struct Date {
	  // Datenmember, Membervariables
	  int day;
	  int month;
	  int year;
  };

  Date easter(int year) {
	  // Datum ausrechnen

	  // Datum zurückgeben
	  Date d;
	  d.day = day; // Punktsyntax kennen wir schon
	  d.month = month;
	  d.year = year;
	  return d;
  }

  struct Character {
  wchar_t clear;
  wchar_t encrypted;
  int count;
  };

  Character c;
  c.count = 0;
  c.count += 1;
  #+END_SRC
* Objektorientiere Programmierung
  Eigene Datentypen mit Kapselung. Eigene Datentypen sind zusammengesetz aus
  einfachen existierenden Datentypen (Ausnahme: enum), zwei Arten:
  - offene Typen: Benutzer kann auf interne Daten zugreifen, "C-style types"
	wenige Beispiele in der Standardbibilothek:
	- std::pair
	- std::tm (von C übernommen)
	- std::div_t (Resultat von div(), zwei Returnwerte: Quotient und Rest)
  - gekapselte Typen: Benutzer kann nicht auf interne Daten zugreifen "private".
	Alle Benutzerzugriffe über Offentliches Interface "public". Vorteile:
	- komplexe Details zur Verwaltung bleiben verborgen
	- öfftenliches Interface (hoffentlich) einfach, zum Beispiel std::vector
	- interne Details können bei Bedarf geändert werden, ohne dass sich das öfftenliche Interface ändert
	  $\implies$ Benutzer muss Code nicht änder, aber plötzlich geht Programm schneller, "Rückwärts-Kompatibilität"
  Wie erreicht man Kapselung? \\
  Zwei Schlüsselwörter für eigene Typen "class" (Konvention OOP), "struct" (von C übernommen) \\
  Zwei Schlüsselwörter für Kapselung: "public" (öffentlicher Teil), "private" (gekapselter Teil). class ist
  standardmäßig "private", struct standardmößig "public"
  #+BEGIN_SRC cpp
  class MyType {
	  // private by default
	  public:
	  // jetzt öffentlich
	  private:
	  // wieder private
	  public:
	  // etc.
  }; // <--- Semikolon wichtig
  struct MyType {
	  // öffentlich by default
	  private:
	  // jetzt privat
	  public:
	  // etc
  };
  #+END_SRC
  Benutzer können nur auf Funktionalität in public-Teil zugreifen. \\
  Die im zusammengesetzten typ enthaltenen daten heißten "Daten-Members", "member variables" sind
  normalerweise "private" $\implies$
  - kann nachträglich geändert werden, zum Beispiel comples real/imaginär vs. Betrag/Phase
  - Benutzer kann nicht unbeabsichtigt die Konsistenz verletzen (zum Beispiel versentlich negativer Betrag bei complex)
  Running example: Punkt-Klasse für 2-dimensionalen PUnkt
  #+BEGIN_SRC cpp
  class Point {
	  double x_; // Koordinaten als private
	  double y_; // Datenmenber (Konvention "_" am Ende)
  };
  #+END_SRC
  dieser Typ ist unbenutzbar, weil alle privat. \\
  unverzichtabr: öfftenliche Punktion zum Initialisieren des Speichers = "Konstructoren"
  - Prozeduren innerhalb der Klasse, Name gleich Klassenamen, Returntyp muss weggelassen werden (fügt Compiler automatisch ein) $\implies$ nur Seiteneffekt:
	neues Objekt initialisieren, also die Konstruktoren der Datenmember aufrufen.
  - zur Erinnerung: zwei Möglichkeiten für normale Variableninitialisierung
	#+BEGIN_SRC cpp
	double z = 1.0;
	double z(1.0); // nur diese Syntax im Konstruktor erlaubt.
	double z{1,0}; // seit c++11

	class Point {
		double x_;
		double y_;
	public:
		Point(double x, double y) :x_(x), // Member x_ auf Initialwert x vom Prozedurargument setzen
		y_(y) // Member y_ auf Initialwert y vom Prozedurargument setzen
		{
		// normaler Rumpf der Prozedur, hier leer, weil nichts zu tun
		// Datenmenber hier schon fertig initialisiert und können benutzt werden
		}
	};
	Point p(1.0, 2.0);
	Point q = {3.0, 4.0}
	#+END_SRC
	Spezieller Konstruktor: ohne Argument = Standardkonstruktor, "default constructor", initialisiert Objekt in Standardzustand. Zum Beispiel bei Zahlen auf 0 setzten, hier au Koordinatenursprung Point origin; $\iff$ Point origin(0.0, 0.0);
	#+BEGIN_SRC cpp
	class Point {
	// ... wie zuvor
	Point() : x_(0.0), y_(0.0) {} // Standardkonstruktor
	};
	#+END_SRC
  um mit Punkt-Objekten zu arbeiten, brauchen wir weitere Funktionen: zwei Möglichkeiten
  - Member-Funktionen: innerhalb der Klasse definiert (wie Konstruktor), dürfen auf alles private zugreifen, können als private oder public definiert sein
  - freie Funktionen: normale Funktionen außerhalb der Klasse, die ein Argument des neuen Typs haben, können nur auf Öffentliches Interface zugreifen
  wichtigeste Vertreter der Member-Funkitonen: Zugriffsfunktionen "Getter": erlauben Benutzer, aktuellen Zustand abzufragen:
  #+BEGIN_SRC cpp
  std::vector<int> v = {1, 2, 3};
  v.size(); // getter für Arraygröße
  Point p(1,0, 2.0);
  p.x() // -> 1.0 x-Koordinate abfragen
  p.y() // -> 2.0 y-Koordinate abfragen
  #+END_SRC
  Member-Funktionen werden mit Punkt-Syntax aufgefuren: p.x(), das Objekt for dem Punkt ist das "nullte" Argument der Funktion, Compiler macht daraus x(p).
  Bei Implementation der Member Funktion schreibt man das nullte Argument nicht hin. Der Compiler stellt es automatisch unter dem Namen "(*this)" zur Verfügung.
  #+BEGIN_SRC cpp
  class Point {
	  // ... wie zuvor
	  double x() const {
		  return (*this).x_;
	  }

	  double y() const {
		  return (*this).y_;
	  }
  };
  #+END_SRC
  Meist kann man (*this) weglassen, wenn eindeutig ist, welchen Member man meint, fügt es der Compiler es automatisch ein.
  Getter-Funktionen sind read-only (ändern die Member-Variablen nicht), man sollte sie deshalb mittels "const" explizit als read-only markieren.
  Vorteile:
  - Programmierer kann Member-Variablen nicht irrtümlich ändern
  - Funktion kann in Kontexten benutzt werden, wo das Objekt (nulltes Argument) explizit als read-only markiert ist.
	#+BEGIN_SRC cpp
	Point const cp(1.0, 2.0); // write-once
	cp.x();
	#+END_SRC
  Point auf Konsole ausgeben: nach String wandeln und String ausgeben
  - zwei Möglichkeiten:
  #+BEGIN_SRC cpp
  // Member Funktion:
  std::cout << p.to_string() << endl;
  class Point {
	  // ... wie zuvor
	  std::string to_string() const {
		  std::string res;
		  res += "[" + std::to_string((*this).x()) + "," + std::to_string((*this).y()) + "]"
		  return res;
	  }
  };

  // freie Funktion:
  std::cout << to_string(p) << endl;
  std::string to_string(Point p) const {
	  std::string res;
	  res += "[" + std::to_string((*this).x()) + "," + std::to_string((*this).y()) + "]"
	  return res;
  }
  #+END_SRC
  Was man wählt ist Geschmackssache (freie Funktion ist kompatibel zu std::to_string, kleiner Vorteil). \\
  Punkte vergleichen:
  #+BEGIN_SRC cpp
  class Point {
	  // ... wie zuvor
	  bool equals(Point other) const {
		  return (*this).x() == other.x() && (*this).y() == other.y();
	  }
	  bool operator==(Point other) const {
		  return (*this).x() == other.x() && (*this).y() == other.y();
	  }
	  bool operator!=(Point other) const {
		  return (*this).x() != other.x() || (*this).y() != other.y();
	  }
  }

  Point p(1.0, 2.0);
  Point origin;
  assert(p.equals(p));
  assert(!p.equals(origin));
  // üblicher: Infix-Notation
  assert(p == p);
  assert(!(p == origin));
  assert(p != origin);
  #+END_SRC
  Für Infix-Notation muss Prefix-Varante operator== und operator!= implementiert werden.
  #+BEGIN_SRC cpp
  p == origin; // -> p.operator==(origin) -> operator==(point, origin)
  #+END_SRC
  zwei weitere Funktionen:
  - neuen Punkt erzeugen, transponiert, das heißt x- und y-Koordinate vertauscht.
  - verschoben um Punkt
  #+BEGIN_SRC cpp
  class Point {
	  // ... wie zuvor
	  Point transpose() const {
		  Point res((*this).y(), (*this).x());
		  return res;
	  }
	  Point translate(Point v) const {
		  Point res((*this).x() + v.x(), (*this).y() + v.y());
		  return res;
	  }
  }
  #+END_SRC
  Jede Klasse hat bestimmte spezielle Menber-Funktionen:
  - Konstruktoren bringen Objekt in wohldefinierten Anfangszustand
  - Destruktoren: Entsorgt ein nicht mehr benötigtes Objekt (meist am Ende der Umgebung)
  - Zuweisungsoperatoren: um Objekt per Zuweisung ("=") zu überschreiben $\implies$ später
** Destruktoren
   jede Klasse muss genau einen Destruktor haben, wenn der Programmierer das nicht expliziet implementiert,
   fügt Compiler ihn automatisch ein. Syntax:
   #+BEGIN_SRC cpp
   class klassenName {
   public:
	   ~klassenName(){
		// Implementation
		}
   };
   #+END_SRC
   Der automatische Destruktor ruft einfach die Destruktoren aller Member-Variablen auf. Meist ist
   das ausreichend, aber in bestimmten Situationen muss der Programmierer zusätzliche Aktionen implementieren.
   Beispiele dafür:
   1. manuelle Speicherverwaltung: Destruktor muss nicht mehr benötigten Speicher an
	  Betriebssystem zurückgeben ($\implies$ später), zum Beispiel Destruktor von
	  std::vector, std::string (Kapselung: Benutzer merken davon nichts)
   2. manuelles Dateimanagement: Destruktor muss Datei schließen, also Dateien aus
	  dem Festplattencache auf Platte übertragen und Metadaten für Datei schreiben, zum Beispiel
	  std::ofstream, std::ifstream
   3. Abmelden von einem Service (ausloggen, Verbindung beenden)
** Kopier-Konstruktor
   Spezieller Kontruktor: Kopier-Konstruktor zum Erzeugen einer Kopie eines vorhandenen Objekts,
   das heißt neue Speicherzelle mit gleichem Inhalt.
   #+BEGIN_SRC cpp
   Point p(1.0, 2.0); // Konstruktor mit Initialwert
   Point q = p;       // Kopierkonstruktor
   Point r(p);        // Kopierkonstruktor

   int foo(Point q) {
	   // ...
   }
   int bar(Point const & g) {
	   // ...
   }
   int main() {
	   Pont p(1.0, 2.0);
	   foo(p) // Kopierkonstruktor, um lokales q in foo aus p zu erzeugen, "pass-by-value"
	   bar(p) // g ist neuer Name für p, keine neue Speicherzelle, kein Kopierkonstruktor, "pass-by-reference"
   }

   // Syntax:
   class KlassenName {
   public:
	   klassenName(klassenName const & existing) {
	   // ...
	   }
   };
   #+END_SRC
   Der Compiler erzeugt Kopier-Konstruktor automatisch, falls nicht explizit programmiert = ruft Kopier-Konstruktor
   aller Member-Variablen auf, meistens richtig, Ausnahmen wie oben.
** Standard-Konstruktor
   Spezieller Konstruktor: Standard-Konstruktor ("default constructor"): ohne Argumente,
   bringt Object in Standard-Zustand, zum Beispiel "0" bei Zahlen, "" bei (Leerstring) bei std::string,
   leeres Array std::vector, (0, 0) bei Point. Syntax:
   #+BEGIN_SRC cpp
   class klassenName {
   public:
	   klassenName() {}
	   klassenName() : Initialiserungserte der Member-Variablen {}
   };
   #+END_SRC
   Compiler erzeugt Standard-Konstruktor automatisch, falls es *keinen* eenutzerdefinierten Konstruktor gibt.
** rule of three
   "rule of three": Faustregel: wenn es notwendig ist, eine der drei Funktionen Destruktor, Kopierkonstruktor,
   Kopier-Zuweisung ($\implies$ später) explizit zu implementieren, müssen alle drei explizit implementiert werden
** Vorteile der Kapselung:
   1. Benutzung der Klasse ist viel einfacher, weil unwichtige Details verborgen sind
   2. interne Implementatoin kann geändert werden, ohne den Benutzer zu Folgeänderungen zu zweingen,
	  weil externe Schnittstelle erhalten bleibt.
** Arithmetische Infix-Operationen
   Ziel der OO-Programmierung: Arbeiten mit Nutzer-definierten Datenstruktoren möglichst einfach, wie mit eingebauten. Zum Beispiel arithmetische Infix-Operationen
   #+BEGIN_SRC cpp
   Point p(2.0, 3.0), q(4.0, 5.0);
   Point r = 2.5 * p + q;
   assert(r == Point(9.0, 12.5));
   #+END_SRC
   dazu muss man die entsprechenden Prefix-Funktionen implementieren
   - Addition:
     #+BEGIN_SRC cpp
     Point operator+(Point p1, Point p2) {
         Point res(p1.x() + p2.x(), p1.y() + p2.y());
         return res;
     }

     Point operator+(Point & p1, Point & p2) {
         Point res(p1.x() + p2.x(), p1.y() + p2.y());
         return res;
     }
     #+END_SRC
   - subtraktion, elementweise Multiplikation und Division genauso ("+" überall durch "-", "*", "/" ersetzen)
   - Skalierungsoperation: Multiplikation von Punkt mit Zahl, das heißt zwei verschiedene Argumenttypen
	 $\implies$ zwei Versionen: 2.5*p und p*2.5
     #+BEGIN_SRC cpp
     Point operator*(double s, Point p) {
         Point res(s * p.x(), s * p.y());
         return res;
     }

     Point operator*(Point p, double s) {
         Point res(p.x() * s, p.y() * s);
         return res;
     }
     #+END_SRC
     alle diese Versionen können dank "function overloading" gleichzeitig implementiert sein
   Bisher: freie Funktionen. Falls das erste Argument vom Typ Point oder Point const & ist,
   kann man die Funktionen alternativ als Member-Funktion implementieren:
   #+BEGIN_SRC cpp
   class Point {
       // ... wie bisher
       Point operator+(Point const & other) const {
           Point res(x_ * other.x_, y_ * other.y_);
           return res;
       }
   };
   #+END_SRC
   Vorteil von Member Funktionen: Zugriff auf private Member der Klasse (hier nicht notwendig). \\
   Nachteil:
   - nur möglich, wenn das linke Argument vom Klassentyp ist p*2.5 kann Member Funktion sein, 2.5*p nicht
   - nur möglich,wenn man die Klassendefinition ändern darf
** Objekte nachrträglich verändern
   Bisher: Alle Objekte waren write-once, das heißt Speicher wurde im Konstruktor initialisiert und
   war dann unveränderlich. $\implies$ Paradigma der funktionalen Programmierung - "referentielle Integrität"
   Prozedurale Programmierung erfodert Möglichkeit, Objekte zu änder, zum Beispiel um entsprechende Änderungen in der realen
   Welt wiederzuspiegeln (zum Beispiel Student besteht Prüfung). Möglichkeit 1: Setter-Funktionen
   #+BEGIN_SRC cpp
   class Point {
       // ... wie bisher

       void setX(double new_x) {
           x_ = new_x;
       }

       void setY(double new_y) {
           y_ = new_y;
       }
   };
   #+END_SRC
   Möglichkeit 2: Index-Zugriff, wie bei std::vector
   #+BEGIN_SRC cpp
   Point p(2, 3);
   assert(p[0] == 2 && p[1] == 3);
   p[0] = 4;
   p[1] = 5;
   assert(p[0] == 4 && p[1] == 5);

   // dazu muss die Member-Funktion operator[] implementiert werden
   class Point {
       // ... wie bisher

       double operator[](int index) const {
           if(index == 0) { return x_; }
           if(index == 1) { return y_; }
           // andernfalls Fehlermeldung (Exception -> später)
       }

       double operator[](int index) {
           // implementation identisch / gleicher Quellcode, aber
           // unterschiedlicher Maschienencode
       }
   }

   // Verwendung (Langform):
   Point p(2.0, 3.0);
   double & x = p[0]; // neue Namen x, y für Variablen p.x_ und p.y_
   double & y = p[1];
   x = 4.0; // ändert indirekt auch p.x_
   y = 5.0; // ändert indirekt auch p.y_
   #+END_SRC
   Möglichkeit 3 : Zuweisungoperatoren
   #+BEGIN_SRC cpp
   Point p(2, 3), g(4, 5);
   p = 1.0; // beide Koordinaten mit 1.0 überschreiben
   assert(p == Point(1.0, 1.0)) p = q; // Speicherzelle p werden die gleichen
                                       // Werte zugewiesen wie Speicherzelle q
   assert(p == Point(4.0, 5.0)) Point & r =
       q; // Gegesatz r und q sind Namen für gleiche Speicherzelle

   class Point {
       // ... wie bisher

       void operator=(double v) {
           x_ = v;
           y_ = v;
       }

       // copy assignment operator (analog zu copy constructor)
       operator=(Point const & other) {
           x_ = other.x_;
           y_ = other.y_;
       }
   }
   #+END_SRC
   Bemerkung:
   1. implementiert der Programmierer keinen copy assignment Operator, implementiert
	  Compiler ihn automatisch (wieKopierkonstruktor): ruft copy assignment für alle Member-Variablen auf
   2. man implementiert meist
   #+BEGIN_SRC cpp
   Point & operator=(...) {
       // ... wie bisher
       return *this;
   }
   #+END_SRC
   Vorteil: man kann Zuweisung verketten:
   #+BEGIN_SRC cpp
   r = p = q; // -> r = (p = q)
   #+END_SRC
   arithmetische Zuweisung:
   #+BEGIN_SRC cpp
   Point p(2, 3),
   q(4, 5);
   p += q; // add -asign: Abbkürzung für p = p + q
   assert(p == Point(6, 8));

   class Point {
       // ... wie bisher
       Point & operator+=(Point const & other) {
           x_ += other.x_;
           y_ += other.y_;
           return *this;
       }
   };
   #+END_SRC
** Klasse Image
   Speichert 2D Bild (analog: Matrix) zunächst nur Graubilder, später: Farbbilder.
   Beispiel für dynamische Datenstruktor, Größe erst zu Laufzeit bekannt und änderbar.
   Besteht aus Pixeln ("picture elements"), die mit 2 Indizes x und y angesprochen werden
   Problem: Speicher ist 1-dimensional, Lösung: Lege Zeieln hinterineanger ab.
   $\implies$ Übergangsformeln:
   \begin{align*}
   i &= x + y \cdot width \\
   x &= 1 %% width \\
   y &= \frac{1}{width}
   \end{align*}
   #+BEGIN_SRC cpp
   class Image {
       int                   width_, height_;
       std::vector<uint16_t> data_;

   public:
       Image() : width_(0), height_(0) {}
       Image(unsigned int w, unsigned int h)
           : width_(w), height_(h), data_(w * h, 0) {}
       int  width() const { return width_; }
       int  height() const { return height_; }
       int  size() const { return width_ * height_; }
       void resize(unsigned int w, unsigned int h) {
           width_  = w;
           height_ = h;
           data.resize(w * h);
       }
       uint16_t get(int x, int y) const { return data_[x + y * width_]; }
       void set(int x, int y, uint16_t v) { data_[x + y * width_] = v; }

       // Zugriff bequemer: wünschenswert:
       // uint16_t v = image[1, 2];
       // image[1, 2] = 255;
       // geht nicht, weil im Indexoperator nur 1 Argument sein darf
       // -> verwende Stattdessen runde Klammern
       uint16_t operator()(int x, int y) const {
           return get(x, y); // return data_[x + y * width_];
       }
       uint16_t operator()(int x, int y) {
           return return data_[x + y * width_];
       }
       // damit: uint16_t = image(1, 2); image(1, 2) = 255;
   };


   std::string to_string(Image const & im) {
       std::string res;
       for(int x = 0; x < im.width(); x++) {
           for(int y = 0; y < im.height(); y++) {
   			   res += std::to_string(im(x, y)) + " ";
           }
   		   res.pop_back();
   		   res += "\n";
       }

   	   return res;
   }
   #+END_SRC
   PGM-Format ("Portable GrayMap"): reines Textformat:
   my_image.pgm:
   #+begin_example
   P2
   # Kommentar
   <width> <height>
   255
   Ausgabe von to_string
   #+end_example
** Verschiedene Konstruktoraufrufe
   Vor c++11 gab es nur () oder gar keine Klammern (Standardkonstruktor).
   #+BEGIN_SRC cpp
   std::vector<int> v0; // leeres Array
   std::vector<int> v1(10, 1); // 10 Elemente mit Initialwert 1
   std::vector<int> v2(v1); // Kopierkonstruktor
   std::vector<int> v3(v1.begin(), v1.end()); // Kopie mittels Iteratorpaar
   #+END_SRC
   Nachteil: Initialisierung mit Array-Literal wurde nicht unterstützt: c++11 schließt Lücke mittels \{\}
   #+BEGIN_SRC cpp
   std::vector<int> v4{1, 2, 3, 4}; // vier Elemente
   #+END_SRC
   Problem: neue Syntax \{\} muss rückwärtskompatibel zu allen () sein $\implies$ kompizierte Regeln
   1. gibt es einen Konstruktor mit $k$ Argumenten und einen Array-konstructor (mit beliebig vielen Argumenten) rufen () den k-Argument-konstruktor auf, \{\} den Array-Konstruktor:
      #+BEGIN_SRC cpp
	  std::vector<int> v1(10, 1); // Konstruktor mit 2 Argumenten, 10 Elemente mit Wert 1
	  std::vector<int> v5{10, 1}; // Array-Konstruktor: 2 Elemente mit Wert 10 und 1
      #+END_SRC
	  Der Array-konstruktor hat als Argument den Typ std::initializier_list<ElementTyp>.
	  Beispiel(Hausaufgabe): verhälft sich ähnlich zu std::vector (Indexschleifen, Kopieren, Iteratoren)
      #+BEGIN_SRC cpp
	  class Polynomial {
	      std::vector<int> a_;

	  public:
	      Polynomial(std::initializier_list<int> l) : a_{l} {} // kopiere das Initialarray l

	      Polynomial(std::initializier_list<int> l) : a_{l.size()} {
		      for(int i = 0; i < l.size(); i++) {
		          a_[i] = l[i];
		      }
		  }
	  };

	  Polynomial p{1, 2, 3}; // \(1 + 2x + 3x^2\)
      #+END_SRC
   2. gibt es keinen Array-Konstruktor (kein Argument std::initializer_list) sind () und \{\} #quivalent
      #+BEGIN_SRC cpp
	  Point p1(2, 3); // \(x\equiv 2, y\equiv 3\)
	  Point p2{2, 3}; // \(x\equiv 2, y\equiv 3\)
      #+END_SRC
   weitere Regeln: googeln nach "universal construction c++" $\implies$ für Fortgeschrittene
** Fehlermeldungen mittels Exceptions ("Ausnahmen")
   Normalerweise werde Funktionen mit "return" beendet. Tritt in der Funktoin ein Fehler auf, kann man
   den Rückgabewert nicht ausrechnen $\implies$ müssen Funktion anders verlassen. Exceptions
   verlassen Funktion mittels "throw" (werfen)
   - Argument von throw (Rückgabewert) ist ein Exception-Object, das den Fehler beschreibt (zum Beispiel Fehlermeldung)
   - vordefinierte Exceptionsklassen im Header <stdexcept>, kann auch eigene definieren. Zum Beispiel std::runtime_error "Universalfehler"
   #+BEGIN_SRC cpp
   class Point {
   // ... wie zuvor

       double operator[](int index) const {
           if(index == 0) {
               return x_;
		   }
           if(index == 1) {
               return y_;
           }
           throw std::runtime_error("Point::operator[]: index out of bound");
       }
   };
   #+END_SRC
   In der aufrufenden Funktion: wirft ein Funktionsaufruf eine Exception, wird standardmäßig die aufrufende Funktion ebenfalls mit "throw" beendet, wobei
   das Exception-Objekt weitergegeben wird.
   #+BEGIN_SRC cpp
   void foo() {
       Point p(2, 3);
       p[2] = 5; // Exception: index 2 verboten $\implies$ foo wird auch beendet foo wird auch beendet
   }

   int main() {
       foo(); // Exception $\implies$ main wir auch beendet und damit das Programm. Alte Compiler geben dann einfach "abort" aus $\implies$ vermeiden durch try/catch, neue Compiler geben die Fehlermeldung aus
   }
   #+END_SRC
   Um die Exception zu "fangen" und zu behandeln (zum Beispiel Fehler reparieren und retry) bracht man
   eine try/catch-Umgebung
   #+BEGIN_SRC cpp
   try {
       foo(); // Aufruf, der Exceptions werfen könnte
       // ... weiterer Code, wenn foo() geklappt hat
   } catch(std::runtime_exception & e) { // Alternativumgebung, wenn foo() Exception wirft
       std::cerr << "Exception aufgetreten: " << e.what() << std::endl;
   }
   #+END_SRC
   Prinzip:
   - tritt im try-Block eine Excpetion auf, wird der Block verlassen $\implies$ die Anweisungen im try-Block *hinter* dem fehlerhaften Aufruf werden nicht mehr ausgeführt
   - folt ein catch mit passendem Exception-Typ, sprint die Ausführung in diesen catch-Block $\implies$ es kann beliebig viel catch-Blöcke für verschiedene Exceptions geben
   - Universal-Catch-Block:  catch(std::exception & e) fängt alles auf (genauer: alle von std::exception abgeleiteten Exceptions-Vererbung $\implies$ später)
   Beispiel: warten auf korrekte Benutzereingabe
   #+BEGIN_SRC cpp
   void process_user_input() {
       double input = 0.0;
	   bool input_valid = false;
	   while(!input_valid) {
	       try {
		       input = get_user_input(); // wirft runtime_error, wenn falscher Input
			   input_valid = true;
		   } catch(std::exception & e) {
		       std::cerr << "falsche Eingabe: " << e.what() << "\n versuche es nochmal!\n";
		   }
	   }

	   // verarbeite Input
   }
   #+END_SRC
** Template-Klassen
   Wir hatten: Template-Funktionen
   #+BEGIN_SRC cpp
   template<typename T>
   T sq(T x) { return x * x; }
   #+END_SRC
   Beispiel: Image-Klasse soll beliebige Pixeltypen unterstützen, bisher uint16_t, danach auch uint8_t (Speicher sparen), float(Genauigkeit bei Bildanalyse), RGB-Typ (Farbbilder).
   Vorgehen bei der Templatisierung
   1. Implementiere Klasse und Tests *ohne* Template (hier: fest definierter Pixeltyp uint16_t) $\implies$ können nach und nach Templatisieren und jeden Schritt durch Test prüfen (gehen die Tests nicht mehr, haben wir einen Fehler gemacht und müssen den
      letzen Schritt rückgängig machen und anders versuchen)
   2. Neue Typnamen einführen mit typedef OldType NewType
	  1. in der Testfunktion
         #+BEGIN_SRC cpp
		 void test_image_uint16_t() {
		 typedef Image Img; // wird später zu typedef Image<uint16_t> Img
		     Img img(10, 20); // Breite 10, Höhe 20
		     assert(img.width() == 10);
		     assert(img.height() == 20);
		     assert(img(0, 0) == 0);
		     img(0, 0) = 255;
		     assert(img(0, 0) == 255);
		 }
         #+END_SRC
	  2. in der Klasse für den Pixeltyp alle Vorkommen von uint16_t (als Pixeltyp) durch "PixelType" ersetzen $\implies$ alle tests müssen weiterhin funktionieren, weil nur neue Typnamen, gleiche Funktionalität
         #+BEGIN_SRC cpp
		 class Image {
		     int width_, height;
		     std::vector<uint16_t> data_;
		 public:
		     uint16_t operator()(int x, int y) {
		         return data[x + y * width_];
		     }

		     // ...
		 };
         #+END_SRC
		 $\to$
         #+BEGIN_SRC cpp
		 class Image {
		 public:
		     typedef uint16_t PixelType;
		 private:
		     int width_, height;
		     std::vector<PixelType> data_;
		 public:
		     PixelType operator()(int x, int y) {
		         return data[x + y * width_];
		     }

		     // ...
		 };
         #+END_SRC
   3. Klasse templatisieren: typedef aus 1. durch Template-Deklaration ersetzen
      #+BEGIN_SRC cpp
	  template<typename PixelType>
	  class Image {
	  // wie zuvor, nur ohne typedef
	  };
      #+END_SRC
   4. Tests anpassen:
	  1. typedef aktualisieren
         #+BEGIN_SRC cpp
		 void test_image_uint16_t() {
		     typedef Image<uint16_t> Img; // überall, wo Img verwendet wird, hat sich jetzt automatisch der Typ von Image nach Image<uint16_t> geändert
		 }
         #+END_SRC
	  2. freie Funktionen sind noch nicht templatisiert $\implies$ vorübergehend auskommentieren, ebenso
		 die zugehörigen Tests (zum Beispiel to_string(), readPGM(), writePGM())
	  3. verbleibende Tests ausführen, müssen immer noch funktionieren
	  (die Typdeklaration Image<uint16_t> wird vom Compiler so implementiert, dass in der Templateklasse Image alle Vorkommen des Typ-Platzhalters "PixelType" durch den Type "uint16_t" ersetzt werden.
      Das ist "Template Instanziierung", das heißt erzeugen einer echten Klasse aus einer Template-Klasse)
   5. *eine* freie Funktion auswählen, wieder einkommentieren (zusammen mit ihren Tests) und templatisieren, zum Beispiel
      #+BEGIN_SRC cpp
	  std::string to_string(Image const & img);
	  // wird zu
	  template<typename PixelType>
	  std::string to_string(Image<PixelType> const & img);
	  // Implementation bleibt zufällig gleich in diesem Fall
      #+END_SRC
   6. Test ausführen, müssen wieder funktionieren, zurück zu Schritt 5, bis alle freien Funktionen templatisiert sind
   7. weitere Testfuktion für einen anderen Pixeltyp schreiben
      #+BEGIN_SRC cpp
	  void test_image_float() {
	  typedef Image<float> Img;
	  // ähnliche Tests wie in test_image_uint16_t(), aber *auch* mit krummen Zahlen (ging vorher nicht), klappt das *nicht*, hat man oft uint16_t irgendwo nicht durch PixelType ersetzt
	  }
      #+END_SRC
	  $\implies$ erst, wenn beide Testfunktionen laufen, kann man relativ sicher sein, das Templatisierung erfolgreich
* Adressen und Zeiger
  Bisher: Speicherzellen werden über Variablennamen angesprochen (oder mehrere Namen für gleiche Speicherzelle, falls Referenzen).
  Adressen sind Alternative, um Speicherzelle zu identifizieren. Betrachte den gesamten Speicher des Comupters als *ein*
  riesiges Array vom Type "byte" (globaler Index vom Betriebssystem festgelegt). Der globale Index heißt
  Adresse des bytes. Die Adresse des esten Bytes einer Speicherzelle heißt Adresse der Speicherzelle.
  $\implies$ kennt man die Adresse einer Speicherzelle und ihren Typ, kann man den Speicher genauso identifizieren wie
  mit Variablenklammern. Konvention: die Adresse $0$ wird nicht verwendet $\implies$ interpretiert als "ungültige Adresse".
  Die Adresse einer Speicherzelle kann von einer Variable mit dem Adressoperator erfragt werden. (unäre &-Operator)
  #+BEGIN_SRC cpp
  int i = 3;
  std::cout << "Adreesse von i: " << &i << std::endl; // Nicht mit binärem und-Operator verwechseln
  #+END_SRC
  Adressen ewrden Standardmäßig im Hexadezimalformat angezeigt. Hex: zur Basis 16, Ziffer 0-9,a-f, Prefix: 0x. Zum Beispiel
  |    0x1 |     1 |
  |    0xa |    10 |
  |    0xe |    14 |
  |   0x10 |    16 |
  |   0x11 |    17 |
  |   0x1a |    26 |
  | 0xbeaf | 48815 |
  "Zeiger" sind spezielle Variablen, mit denen man Adressen speicher kann. (englisch Pointer)
  #+BEGIN_SRC cpp
  int i = 3;
  int * ptr_i = &i; // Initialisierung
  int * ptr2 = ptr_i; // Kopierkonstruktor: weiterer Zeiger mit der selben Adresse wie ptr_i
  int * ptr3 = 0; // ungültige Adresse

  if(!ptr3) {
  // ungülge Adresse
  } else {
  // gültige Adresse
  }
  #+END_SRC
  Um vom Zeiger zur Variablen zurückzukommen, benutzt man den Dereferenzierungsoperator * (von Iteratoren bereits bekannt) $\implies$ Ergebnis: Referenz auf die Speicherzelle, die bei der Adresse beginnt
  #+BEGIN_SRC cpp
  int i = 3;
  int * ptr_i = &i;
  int &j = *ptr_i; // j ist neuer Name für i, äquivalent zu int & j = i;
  j = 5; // i ändert sich auch
  *ptr_i = 7; // i und j ändern sich, Schreibender Zugriff über den Zeiger, Compiler legt intern eine temporäre Referenz an
  int k = *ptr_i; // eine neue Variable mit dem selben Wert wie *ptr_i (= 7
  #+END_SRC
  Adressoperator und Dereferenzierungsoperator sind invers: für alle Variablen gilt:
  #+BEGIN_SRC cpp
  assert(i == *(&i));
  #+END_SRC
  Nulltes Argument von Member-Funktionen ist eigentlich ein *Zeiger* auf die Adresse des aktuellen
  Objekts this: Zeiger, wir haben daraus Referenz erzeugt (*this)
** Wozu verwendet man Zeiger?
   Heute versucht man, Zeiger so weit wie möglich in Objekte zu kapseln $\implies$ einfacher, weniger Fehler
   zum Beispiel std::vector versus old-type C-Arrays. In C gibt es noch keine Referenzen $\implies$
   benutze Zeiger um Referenzen zu simulieren:
   C++:
   #+BEGIN_SRC cpp
   void foo(int & i) {
       i = 5;
   }

   int j = 3;
   foo(j);
   assert(j == 5);
   #+END_SRC
   C:
   #+BEGIN_SRC cpp
   void foo(int * i) {
       *i = 5;
   }

   int j = 3;
   foo(&j);
   assert(j == 5);
   #+END_SRC
   $\implies$ wenn man aus c++ eine Bibilothek aufrufen (zum Beispiel um TIFF oder JPEG zu erzeugen) braucht man oft Zeiger.
** Anwendungen der Zeiger
   1. Ersatz für Referenzen (bis in C)
   2. für Variablen, die auch ungültig sein können
	  1. für optionale Argumente:
         #+BEGIN_SRC cpp
		 int foo(int * a = 0) { // Default Argument, setzt der Compiler automatisch ein, wenn Benutzer es nicht angibt
		     if(a == 0) { // ungültige Adresse $\implies$ Benutzer hat kein Argument übergeben
			     // Berechnung mit einem Standard-Wert für a
			 } else {
			     // Berechnung mit gegebenem Wert (*a)
			 }
		 }

		 // Verwendung:
		 foo(0); // Nullpointer $\iff$ ungültig $\implies$ Standardberechung
		 int a = 2;
		 foo(&a); // Berechung mit Wert = 2
		 foo(); // Compiler mach daraus automatisch foo(0);
         #+END_SRC
	  2. wenn eine Funktion fehlschlägt: (typisch für C). Öffnen einer Datei in C:
         #+BEGIN_SRC cpp
		 FILE * file = fopen("filename");
		 if(!file) { // ungültige Adresse
		     std::cerr << "unable to open file: filename" << std::endl;
			 return; // throw
		 }
		 // file lesen
         #+END_SRC
		 bessere Lösung in c++: kapseln und bei Fehler Exception werfen $\implies$ if(file == 0) kann nicht vergessen werden.
	  3. Variablen, die nacheinander auf verschiedene Speicherzellen zeigen, typisch: "Iteratoren" in c
         #+BEGIN_SRC cpp
		 int array[100]; // C-Array, Größe 100
		 int * iter = &(a[0]); // Zeiger auf erstes Element $\estimates$ std::vector.begin()
		 int * end = iter + 100; // Zeiger hinter letztes Element $\estimates$ std::vector.end()

		 int c = 0;
		 for(;iter != end; iter++, c++) {
		     *iter = c; // Array mit 0, 1, 2, 3, $\ldots$, 99 initialisierenn
		 }
         #+END_SRC
		 Syntax wie bei Iteratoren, weil Iteratoren nach dem Vorbild der Zeiger definiert wurden.
	  4. manuelle Speicherverwaltung:
		 - Speicherzellen, die mit Schlüsselwort "new" angelegt wurden, gibt der Compiler am Ende der Umgebung *nicht* automatisch frei
		 - wenn nicht mehr benötigt, muss der Programmierer den Speicher mit "delete" manuell freigeben
		 - das Resultat von "new" ist Adresse der Speicherzelle $\implies$ an Zeiger zuweisen
         #+BEGIN_SRC cpp
		 Image * img = 0; // Zeiger auf Bild, anfangs ungültig
		 {
		     // ... Breite und Höhe erfragen
		     img = new Image(width, height);
		 } // img wird *nicht* automatisch freigegeben
         (*img)(0, 0) = 255; // Pixel (0, 0) überschreiben
		 Image & image = *img; // Referenz auf Speicherzelle an Adresse "img"
		 image(1, 1) = 128; // Pixel (1, 1) schreiben
		 // Wichtig!!!!!!!!:
		 delete img; // Speicher händisch freigeben, nicht vergessen (sonst Speicherleck) aber auch nicht zu früh (sonst Absturz)
         #+END_SRC
		 In c++ verwende "smart pointer" std::unique_ptr, std::shared_ptr $\implies$ rufen delete automatisch im richtigem Moment auf (std::shared_ptr<Image> img = new Image(w, h))
		 Für Arrays gibt es analog new[], delete[]. Beispiel: manuelle Speicherverwaltung im Image
         #+BEGIN_SRC cpp
		 class Image {
		     int width_, height_;
		     uint16_t * data_; // war: std::vector<uint16_t> data_;
		 public:
		     Image(unsigned int w, unsigned int h) : width_(w), height_(h), data_(new uint16_t[w * h]) { // manuelle Array-Allokation
		         for(int i = 0; i < w * h; i++) {
		             data_[i] = 0;
		         }
		     }

             // Jetzt ist der automatisch generierte Kopierkonstruktor ungeeignet $\implies$ manuell implementieren
			 Image(const Image & other) : width_(other.width_), height_(other.height_), data_(new uint16_t[width_ * height_]) { // manuelle Speicher-Verwaltung
			     for(int i = 0; i < width_ * height_; i++) {
				     data_[i] = other.data_[i];
				 }
			 }

			 // analog: Kopierzuweisung manuell implementieren, "rule of three"
			 // Destruktor
			 ~Image() {
			     delete[] data_; // Array freigeben (falls delete ohne [] $\implies$ Absturz)
			 }
		 }
         #+END_SRC
	  5. Heterogene Container: normale Container (std::vector<double>) sind *homogen* $\estimates$ Elemente haben gleichen Typ (double).
		 Manchmal braucht man Container, die Objekte verschiedener Typen aufnehmen "heterogen", dafür braucht man Zeiger und *Vererbung*
* Vererbung
  Vererbung war am Anfag der objekt-orientierten Programmierung Lösung für alles. Heute ist der Hype vorbei, eine Technik unter vielen, sparsam eingesetzt, besonders
  bei GUI (graphical user interface) und bei Zeichenprogrammen/Computer Graphik. Eine Klasse (abgeleitete Klasse, Unterklasse) kann
  Funktionalität einer anderen Klasse (Basisklasse) erbe, Basisklasse muss dafür nicht sterben. Sprachunabängige Schreibweise: UML-Diagramm ("Universal modelling language")
  # (TODO: typeset uml diagramm (tikz-uml))
  #+begin_export latex
  \catcode`(=12
  \catcode`)=12
  #+end_export
  \begin{figure}[H]
  \centering
  \begin{tikzpicture}
  \umlsimpleclass{Base}
  \umlsimpleclass[y = 3]{Derived}
  \umlinherit{Base}{Derived}
  \end{tikzpicture}
  \end{figure}
  #+begin_export latex
  \catcode`(=\active
  \catcode`)=\active
  #+end_export
  in c++:
  #+BEGIN_SRC cpp
  class Base {
  // ...
  };

  class Derived : public Base { // Vererbung
      // ...
      using Base::Base; // Vererbung von Konstruktor erzwingen
  }
  #+END_SRC
  Die Funktionalität aus der Umgebung von Base ist in der Umgebung von Derived sichtbar (wie bei normalen geschachtelten Umgebungen). Ausnahmen:
  - Konstruktoren und Zuweisungsoperatoren werden *nicht* vererbt (in Derived neu implementieren, ab c++11 mit "using" Vererbung erzwingen)
  - private Member sind unsichtbar (aber noch vorhanden)
  $\implies$ in Derived die öffentliche Schnittstelle von Base benutzen. Ausnahme: ersetze "private" in Base durch "protected" $\implies$ protected Members werden in Derived sichtbar
  (aber bleiben von außen privat). Die in Derived geerbte Funktionalität gehört zur Öffentlichen Schnittstelle von Derived $\implies$ Wiederverwendung der Funktionalität vor Base.
  Ausnahme:
  - wenn Derived eine neue Member-Variable oder -fuktion mit dem gleichen Namen implementiert, wird die geerbte Variante *verdeckt* (wie bei normalen Umgebungen auch)
  - man kann die Verwendung der geerbten Version erzwingen durch Doppenpunktnotation Base:: (wie bei Namensräumen std::), Base::data_, Base::foo()
  Im Konstruktor von Derived wird der Konstruktor von Base aufgerufen wie ein Konstruktor der Membervariablen
  #+BEGIN_SRC cpp
  class Base {
      int b_;
  public:
      Base(int b) : b_(b) {}
  };

  class Derived : public Base {
      int d_;
  public:
      Derived(int b, int d) : Base(b), d_(d) {}
  };
  #+END_SRC
* Anwendung von Vererbung
** Spezialisierung
   Spezialisierung "is-a" Beziehung, Derived is a (special kind of) Base. Basisklasse: ungeordneter Container von Point-Objekten ("Punktwolke")
    #+BEGIN_SRC cpp
	class PointSet {
	    // Punktionen wie Anzahl, boundingbox bestimmen, konvexe hülle, Punkte verschieben, skalieren, zeichnen
	};
    #+END_SRC
	abgeleitete Klasse: Polygon, geordnete Punktmenge, jeder Punkt ist mit seinem Nachfolger verbunden.
    #+BEGIN_SRC cpp
	class Polygon : public PointSet {
	    // erbt Funktionalität vor PointSet
		// zusätzliche Funktionalität: Flächeninhalt, Umfang, Test: ist Punkt innen oder außen
		// veränderte Funktionalität: zeichnen
	};
    #+END_SRC
