#+AUTHOR: Robin Heinemann
#+TITLE: Einführung in die Anwendungsorientierte Informatik (Köthe)
#+OPTIONS: H:6
#+LATEX_CLASS: koma-article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage{siunitx}%
#+LATEX_HEADER: \usepackage{fontspec}%
#+LATEX_HEADER: \sisetup{load-configurations = abbrevations}%
#+LATEX_HEADER: \newcommand{\estimates}{\overset{\scriptscriptstyle\wedge}{=}}%
#+LATEX_HEADER: \usepackage{mathtools}%
#+LATEX_HEADER: \DeclarePairedDelimiter\abs{\lvert}{\rvert}%
#+LATEX_HEADER: \DeclarePairedDelimiter\norm{\lVert}{\rVert}%
#+LATEX_HEADER: \DeclareMathOperator{\Exists}{\exists}%
#+LATEX_HEADER: \DeclareMathOperator{\Forall}{\forall}%
#+LATEX_HEADER: \def\colvec#1{\left(\vcenter{\halign{\hfil$##$\hfil\cr \colvecA#1;;}}\right)}
#+LATEX_HEADER: \def\colvecA#1;{\if;#1;\else #1\cr \expandafter \colvecA \fi}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{makecell}
# #+LATEX_HEADER: \usemintedstyle{tango}
#+LATEX_HEADER: \usemintedstyle{perldoc}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{arrows,automata}
#+LATEX_HEADER: \usepackage{tikz-qtree}
#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \setlistdepth{20}
#+LATEX_HEADER: \renewlist{itemize}{itemize}{20}
#+LATEX_HEADER: \setlist[itemize]{label=$\cdot$}

# #+BEGIN_SRC cpp
# for(int i = 0; i < 5) {
#    std::cout << i << std::endl;
# }
# #+END_SRC

* Klausur 10.02.2016

* Was ist Informatik?
  "Kunst" Aufgaben mit Computerprogrammen zu lösen.
** Teilgebiete
*** theoretische Informatik (*ITH*)
    - Berechenbarkeit: Welche Probleme kann man mit Informatik lösen und welche prinzipiell nicht?
    - Komplexität: Welche Probleme kann man effizient lösen?
    - Korrektheit: Wie beweist man, dass das Ergebnis richtig ist? \\
      Echtzeit: Dass das richtige Ergebnis rechtzeitig vorliegt.
    - verteilte Systeme: Wie sichert man, dass verteilte Systeme korrekt kommunizieren?
*** technische Informatik (*ITE*)
	- Auf welcher Hardware kann man Programme ausführen, wie baut man dies Hardware?
	- CPU, GPU, RAM, HD, Display, Printer, Networks
*** praktische Informatik
	- Wie entwickelt man Software?
	- Programmiersprachen und Compiler: Wie kommuniziert der Programmierer mit der Hardware?\hfill *IPI*, *IPK*
	- Algorithmen und Datenstrukturen: Wie baut man komplexe Programme aus einfachen Grundbausteinen?\hfill *IAL*
	- Softwaretechnik: Wie organisiert man sehr große Projekte?\hfill *ISW*
	- Kernanwendung der Informatik: Betriebsysteme, Netzwerke, Parallelisierung\hfill *IBN*
	  - Datenbanksysteme\hfill *IDB1*
	  - Graphik, Graphische Benutzerschnittstellen\hfill *ICG1*
	  - Bild- und Datenanalyse
	  - maschinelles Lernen
	  - künstliche Intelligenz
*** angewante Informatik
	- Wie löst man Probleme aus einem anderem Gebiet mit Programmen?
	- Informationstechnik
	  - Buchhandlung, e-commerce, Logistik
	- Web programming
	- scientific computing für Physik, Biologie
	- Medizininformatik
	  - bildgebende Verfahren
	  - digitale Patientenakte
	- computer linguistik
	  - Sprachverstehen, automatische Übersetzung
	- Unterhaltung: Spiele, special effect im Film
* Wie unterscheidet sich Informatik von anderen Disziplinen?
** Mathematik
   Am Beispiel der Definition $a \leq b: \exists c \geq 0: a + c = b$ \\
   Informatik: \\
   Lösungsverfahren: $a - b \leq 0$, das kann man leicht ausrechen, wenn man subtrahieren und mit $0$ vergleichen kann. \\
   Quadratwurzel: $y = \sqrt{x} \Leftrightarrow y \geq 0 \wedge y^2 = x (\Rightarrow x > 0)$ \\
   Informatik: Algorithmus aus der Antike: $y = \frac{x}{y}$
   iteratives Verfahren: \\ 
   Initial Guess $y^{(0)} = 1$
   schrittweise Verbesserung $y^{(t+1)} = \frac{y^{(t)} + \frac{x}{y^{(t)}}}{2}$
* Informatik
  Lösugswege, genauer Algorithmen
** Algorithmus
   *schematische* Vorgehensweise mit der jedes Problem einer bestimmten *Klasse* mit *endliche* vielen *elementaren* Schritten / Operationen gelöst werden kann
   - schematisch: man kann den Algorithmus ausführen, ohne ihn zu verstehen ($\Rightarrow$ Computer)
   - alle Probleme einer Klasse: zum Beispiel: die Wurzel aus jeder beliebigen nicht-negativen Zahl, und nicht nur $\sqrt{11}$
   - endliche viele Schritte: man kommt nach endlicher Zeit zur Lösung
   - elementare Schrite / Operationen: führen die Lösung auf Operationen oder Teilprobleme zurück, die wir schon gelöst haben
** Daten
   Daten sind Symbole,
   - die Entitäten und Eigenschaften der realen Welt im Computer representieren.
   - die interne Zwischenergebnisse eines Algorithmus aufbewahren
   $\Rightarrow$ Algorithmen transformieren nach bestimmten Regeln die Eingangsdaten (gegebene Symbole) in Ausgangsdaten (Symbole für das Ergebniss).
   Die Bedeutung / Interpretation der Symbole ist dem Algorithmus egal $\estimates$ "schematisch"
*** Beispiele für Symbole
	- Zahlen
	- Buchstaben
	- Icons
	- Verkehrszeichen
    aber: heutige Computer verstehen nur Binärzahlen $\Rightarrow$ alles andere muss man übersetzen
	Eingansdaten: "Ereignisse":
	- Symbol von Festplatte lesen oder per Netzwerk empfangen
	- Benutzerinteraktion (Taste, Maus, ...)
	- Sensor übermittelt Meßergebnis, Stoppuhr läuft ab
    Ausgangsdaten: "Aktionen":
	- Symbole auf Festplatte schreiben, per Netzwerk senden
	- Benutzeranzeige (Display, Drucker, Ton)
	- Stoppuhr starten
	- Roboteraktion ausführen (zum Beispiel Bremsassistent)
	Interne Daten:
	- Symbole im Hauptspeicher oder auf Festplatte
	- Stoppuhr starten / Timeout
** Einfachster Computer
   endliche Automaten (endliche Zustandsautomaten)
   - befinden sich zu jedem Zeitpunkt in einem bestimmten Zustand aus einer vordefinierten endlichen Zustandsmenge
   - äußere Ereignisse können Zustandsänderungen bewirken und Aktionen auslösen
*** TODO Graphische Darstellung
	graphische Darstellung: Zustände = Kreise, Zustandsübergänge: Pfeile
*** TODO Darstellung durch Übergangstabellen
	Zeilen: Zustände, Spalten: Ereignisse, Felder: Aktion und Folgezustände
    | Zustände \ Ereignisse | Knopf drücken                                     | Timeout                                                   | Timeout(Variante)                       |
    |-----------------------+---------------------------------------------------+-----------------------------------------------------------+-----------------------------------------|
    | aus                   | \Rightarrow{halb} \\ {4 LEDs an}                 | %                                                         | (\Rightarrow{aus},{nichts})             |
    | halb                  | (\Rightarrow{voll},{8 LEDs an})                   | %                                                         | (\Rightarrow{aus},{nichts})             |
    | voll                  | (\Rightarrow{blinken an},{Timer starten})         | %                                                         | (\Rightarrow{aus},{nichts})             |
    | blinken an            | (\Rightarrow{aus},{Alle LEDs aus, Timer stoppen}) | (\Rightarrow{blinken aus},{alle LEDs aus, Timer starten}) | (\Rightarrow{blinken aus},{8 LEDs aus}) |
    | blinken aus           | (\Rightarrow{aus},{Alle LEDs aus, Timer stoppen}) | (\Rightarrow{blinken an},{alle LEDs an, Timer starten})   | (\Rightarrow{blinken an},{8 LEDs an})   |

	Variante: Timer läuft immer (Signal alle 0.3s) \Rightarrow Timout ignorieren im Zustand "aus", "halb", "voll"
*** Beispiel 2:
	\begin{align}
	&1~0~1~1~0~1~0 &= 2 + 8 + 16 + 74 &= 90_{\text{dez}} \\
	+&0~1~1~1~0~0~1 &= 1 + 8 + 16 + 32 &= 57_{\text{dez}} \\
	\hline
	1~&0~0~1~0~0~1~1 &= 1 + 2 + 16 + 128 &= 147_{\text{dez}}\checkmark
	\end{align}
**** Implementation mit Endlichen Automaten
	 Prinzipen:
	 - wir lesen die Eingangsdaten von rechts nach links
	 - Beide Zahlen gleich lang (sonst mit 0en auffüllen)
	 - Ergebnis wird von rechts nach link ausgegeben
**** TODO Skizze der Automaten
     | Zustand   | Ereignis    | Ausgeben |
     |-----------+-------------+----------|
     | start     | (0,1)       | "1"      |
     | start     | (1,0)       | "1"      |
     | start     | (0,0)       | "0"      |
     | start     | (1,1)       | "0"      |
     | carry = 1 | (1,1)       | "1"      |
     | carry = 1 | (0,1)       | "0"      |
     | carry = 1 | (1.0)       | "0"      |
     | carry = 1 | $\emptyset$ | "1"      |
	 *Wichtig:* In jedem Zustand muss für *alle möglichen* Ereignisse eine Aktion und Folgezustand definiert werden.
	 Vergisst man ein Ereignis zeigt der Automat undefiniertes Verhalten, also einen "Bug".
	 Falls keine sinvolle Reaktion möglich ist: neuer Zustand: "Fehler" \Rightarrow Übergang nach "Fehler",
	 Aktion: Ausgeben einer Fehlermeldung
***** TODO Skizze Fehlermeldung
	  Ein endlicher Automat hat nur ein Speicherelement, das den aktuelen Zustand angibt. Folge:
	  - Automat kann sich nicht merken, wie er in den aktuellen Zustand gekommen ist ("kein Gedächnis")
	  - Automat kann nicht beliebig weit zählen, sondern nur bis zu einer vorgegebenen Grenze
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm, semithick]
\node[initial,state] (0) {"0"};
\node[state] (1) [right of=0] {"1"};
\node[state] (2) [right of=1]{"2"};
\node[state] (3) [right of=2]{"3"};
\node[accepting,state] [below of=1] (end) {"stop"};
\path (0) edge [loop above] node {"0"} (0)
(0) edge node {"x"} (1)
(0) edge node {$\emptyset$} (end)
(1) edge [loop above] node {"0"} (1)
(1) edge node {"x"} (2)
(1) edge node {$\emptyset$} (end)
(2) edge [loop above] node {"0"} (2)
(2) edge node {"x"} (3)
(2) edge node {$\emptyset$} (end)
(3) edge [loop above] node {"$0\vee x$"} (3)
(3) edge node {"x"} (3)
(3) edge node {$\emptyset$} (end);
\end{tikzpicture}
\end{center}
      Insgesamt: Man kann mit endlichen Automaten nur relativ einfache Algorithmen implementieren. (nur reguläre Sprachen)
	  Spendiert man zusätzlichen Specher, geht mehr:
	  - Automat mit Stack-Speicher (Stapel oder Keller) \Rightarrow Kellerautomat (Kontextfreie Sprachen)
	  - Automat mit zwei Stacks oder äquivalent Turing-Maschine kann alles auführen, was man intuitiv für berechenbar hält
      Markov Modelle: endliche Automaten mit probabilistischen Übergangen.
	  Bisher: Algorithmen für einen bestimmten Zweck (Problemklasse)
	  Frage: Gibt es einen universellen Algorithms für alle berechenbare Probleme?
	  Betrache formale Algorithmusbeschreibung als Teil der Eingabe des universellen Algorithmus.
* Substitutionsmodell (funktionale Programmierung)
  - einfaches Modell für arithmetische Berechnung "Taschenrechner"
  - Eingaben und Ausgaben sind Zahlen (ganze oder reelle Zahlen). Zahlenkonstanten heißten "Literale"
  - elementare Funktionen: haben eine oder mehere Zahlen als Argumente (Parameter) und liefern eine Zahl als Ergebnis (wie Mathematik):
	- add(1,2) \rightarrow 3, mul(2,3) \rightarrow 6, analog sub(), div(), mod()
  - Funktionsaufrufe können verschachtelt werden, das heißt Argumente kann Ergebnis einer anderen Funktion sein
	- mul(add(1,2),sub(5,3)) \rightarrow 6
** Substitutionsmodell
   Man kann einen Funktionsaufruf, dessen Argument bekannt ist (das heißt Zahlen sind) durch den Wert des Ergebnisses ersetzen ("substituieren"). Geschachtelte Ausdrücke lassen sich so von innen nach außen auswerten.
   \[mul(add(1,2),sub(5,3))\]
   \[mul(3,sub(5,3))\]
   \[mul(3,2)\]
   \[6\]
   - Die arithmetischen Operationene add(), sub(), mul(), div(), mod() werden normalerweise von der Hardware implementiert.
   - Die meisten Programmiersprachen bieten außerdem algebraische Funktionen wie: sqrt(), sin(), cos(), log()
	 - sind meist nicht in Hardware, aber vorgefertigte Algorithmen, werden mit Programmiersprachen geliefert, "Standardbibilothek"
   - in C++: mathematisches Modul des Standardbibilothek: "cmath"
   - Für Arithmetik gebräuchlicher ist "Infix-Notation" mit Operator-Symbolen "+", "-", "*", "/", "%"
   - mul(add(1,2),sub(5,3)) \Leftrightarrow ((1+2)*(5-3))
	 - oft besser, unter anderem weil man Klammer weglassen darf
	   1. "Punkt vor Strichrechnung" 3+4*5 \Leftrightarrow 3+(4*5), mul, div, mod binden stärker als add, sub
	   2. Operatoren gleicher Präzedenz werden von links nach rechts ausgeführt (links-assoziativ) \\
		  1+2+3-4+5 \Leftrightarrow ((((1+2)+3)-4)+5)
	   3. äußere Klammer kann man weglassen (1+2)\Leftrightarrow 1+2
   - Computer wandeln Infix zuerst in Prefix Notation um
	 1. weggelassene Klammer wieder einfügen
	 2. Operatorensymbol durch Funktionsnamen ersetzen und an Prefix-Position verschieben
		\[1 + 2 + 3 * 4 / (1 + 5) - 2\]
		\[(((1 + 2) + ((3 * 4) / (1 + 5))) - 2)\]
		\[sub(add(add(1,2),div(mul(3,4),add(1,5))), 2)\]
		\[sub(add(3,div(12,6)), 2)\]
		\[sub(add(3,2), 2)\]
		\[sub(5, 2)\]
		\[2\]
** Bäume
   - bestehen aus Knoten und Kanten (Kreise und Pfeile)
   - Kanten verbinden Knoten mit ihren Kind-knoten
   - jeder Koten (außer der Wurzel) hat genau ein Elternteil ("parent node")
   - Knoten ohne Kinder heißen Blätter ("leaves / leaf node")
   - Teilbaum
	 - wähle beliebigen Knoten
	 - entferne temporär dessen Elternkante, dadurch wird der Knoten temporär zu einer Wurzel, dieser Knoten mit allen Nachkommen bildet wieder einen Baum (Teilbaum des Orginalbaumes)
   - trivialer Teilbaum hat nur einen Knoten
   - Tiefe: Abstand eines Knotens von der Wurzel (Anzahl der Kanten zwischen Knoten und Wurzel)
	 - Tiefe des Baums: maximale Tiefe eines Knoten
*** Beispiel
	\[1 + 2 + 3 * 4 / (1 + 5) - 2\]
	\[sub(add(add(1,2),div(mul(3,4),add(1,5))), 2)\]
	\begin{center}
	\Tree [ .sub [ .add [ .add 1 2 ] [ .div [ .mul 3 4 ] [ .add 1 5 ] ] ] 2 ]
	\end{center}
** Rekursion
   Rekursiv $\estimates$ Algorithmus für Teilproblem von vorn.
** Prefixnotation aus dem Baum rekonstruieren
   1. <<algstart1>> Wenn die Wurzel ein Blatt ist: Drucke die Zahl
   2. sonst:
	  - Drucke Funktionsnamen
	  - Drucke "("
	  - Wiederhole den Algorithmus ab [[algstart1]] für das linke Kind (Teilbaum mit Wurzel = linkes Kind)
	  - Drucke ","
	  - Wiederhole den Algorithmus ab [[algstart1]] für das rechte Kind (Teilbaum mit Wurzel = rechtes Kind)
	  - Drucke ")"
	\Rightarrow \[sub(add(add(1,2),div(mul(3,4),add(1,5))), 2)\]
** Prefixnotation aus dem Baum rekonstruieren
   1. <<algstart2>> Wenn die Wurzel ein Blatt ist: Drucke die Zahl
   2. sonst:
	  - Drucke Funktionsnamen
	  - Drucke "("
	  - Wiederhole den Algorithmus ab [[algstart2]] für das linke Kind (Teilbaum mit Wurzel = linkes Kind)
	  - Drucke Operatorsymbol
	  - Wiederhole den Algorithmus ab [[algstart2]] für das rechte Kind (Teilbaum mit Wurzel = rechtes Kind)
	  - Drucke ")"
	\Rightarrow \[sub(add(add(1,2),div(mul(3,4),add(1,5))), 2)\]
   \Rightarrow *inorder*
** Berechnen des Werts mit Substitutionsmethode
   1. <<algstart3>> Wenn Wurzel dein Blatt gib Zahl zurück
   2. sonst:
	  - Wiederhole den Algorithmus ab [[algstart3]] für das linkes Kind (Teilbaum mit Wurzel = rechtes Kind), speichere Ergebnis als "lhs"
	  - Wiederhole den Algorithmus ab [[algstart3]] für das rechte Kind (Teilbaum mit Wurzel = rechtes Kind), speichere Ergebnis als "rhs"
	  - berechne funktionsname(lhs,rhs) und gebe das Ergebnis zurück
   \Rightarrow *postorder*
* Maschienensprachen
  - optimiert für die Hardware
  - Gegensatz: höhere Programmiersprachen (c++)
	- optimiert für Programmierer
  - Compiler oder Interpreter übersetzen Hoch- in Maschinensprache
** Umwandlung in Maschinensprache
  1. Eingaben und (Zwischen)-Ergebnisse werden in Speicherzellen abgespeichert \Rightarrow jeder Knoten im Baum bekommt eine Speicherzelle
  2. Speicherzellen für Eingaben initialisieren
	 - Notation: SpZ \leftarrow Wert
  3. Rechenoperationen in Reihenfolge des Substitutionsmodell ausführen und in der jeweiligen Speicherzelle speichern
	 - Notation: SpZ-Ergebniss \leftarrow fname SpZArg1 SpZArg2
  4. alles in Zahlencode umwandeln
	 - Funktionsnamen:
	   | Opcode | Wert |
	   |--------+------|
	   | init   | 1    |
	   | add    | 2    |
	   | sub    | 3    |
	   | mul    | 4    |
	   | div    | 5    |
* Funktionale Programmierung
  - bei Maschienensprache werden Zwischenergebnisse in Speicherzellen abgelegt
  - das ist auch in der funktionalen Programmierung eine gute Idee
  - Speicherzellen werden duch Namen (vom Programmierer vergeben) unterschieden
** Beispiel
   Lösen einer quadratischen Gleichung:
   \[ax^2 + bx + c = 0\]
   \[x^2 - 2px + q = 0, p = -\frac{b}{2a},q=\frac{c}{d}\]
   \[x_2 = p + \sqrt{p^2 - q},x_2 = p - \sqrt{p^2 - q}\]
   ohne Zwischenergebnisse:
   \[x_1 \leftarrow add(div(div(b,a),-2),sqrt(sub(mul(div(b,a),-2),div(div(b,a)-1)),div(c,a)))\]
   mit Zwischenergebniss und Infix Notation
   \[p\leftarrow b / c / -2~\text{oder}~p\leftarrow -0.5 * b / a\]
   \[a\leftarrow c / a\]
   \[d\leftarrow sqrt(p*p - q)\]
   \[x_1\leftarrow p + d\]
   \[x_2\leftarrow p - d\]
** Vorteile von Zwischenergebnissen
   1. lesbarer
   2. redundante Berechnung vermieden. Beachte: In der funktionalen Programmierung können die Speicherzellen nach der Initialisierung nicht mehr verändert werden
   3. Speicherzellen und Namen sind nützlich um Argumente an Funktionen zu übergeben \Rightarrow Definition eigener Funktionen
	  #+BEGIN_SRC cpp
	  function sq(x) {
		 return x * x
	  }
	  #+END_SRC
	  \Rightarrow $d \leftarrow sqrt(sq(p) - q)$
	  Speicherzelle mit Namen "x" für das Argument von $sq$
** Funktionale Programmierung in c++
   - in c++ hat jede Speicherzelle einen Typ (legt Größe und Bedeutung der Speicherzelle fest)
	 - wichtige Typen
	   | int         | ganze Zahlen  |
	   | double      | reelle Zahlen |
	   | std::string | Text          |
	   int: $12,-3$ \\
	   double: $-1.02,1.2e-4 = 1.2*10^{-4}$ \\
	   std::string: "text"
   - Initialisierung wird geschrieben als "typename spzname = Wert;"
	 #+BEGIN_SRC cpp
	 double a = ...;
	 double b = ...;
	 double c = ...;
	 double p = -0.5 b / a;
	 double q = c / a;
	 double d = std::sqrt(p*p - q);
	 double x1 = p + d;
	 double x2 = p - d;
	 std::cout << "x1: " << x1 << ", x2: " << x2 << std::endl;
	 #+END_SRC
   - eigene Funktionen in C++
	 #+BEGIN_SRC cpp
	 // Kommentar (auch /* */)
	 type_ergebnis fname(type_arg1 name1, ...) {
	     // Signatur / Funkitonskopf / Deklaration
		 return ergebnis;                      
		 /* Funktionskörper / Definition / Implementation */
	 }
	 #+END_SRC
	 - ganze Zahl quadrieren:
	   #+BEGIN_SRC cpp
	   int sq(int x) {
		   return x*x;
	   }
	   #+END_SRC
	 - reelle Zahl quadrieren:
	   #+BEGIN_SRC cpp
	   double sq(double x) {
		   return x*x;
	   }
	   #+END_SRC
	 - beide Varianten dürfen in c++ gleichzeitig definiert sein \Rightarrow "function overloading" \Rightarrow c++ wählt automatisch die richtig Variable anhand des Argumenttypes ("overload resolution")
	   #+BEGIN_SRC cpp
	   int x = 2;
	   double y = 1.1
	   int x2 = sq(x) // int Variante
	   double y2 = sq(y) // double Variante
	   #+END_SRC
	 - jedes c++-Programm muss genau eine Funktion names "main" haben. Dort beginnt die Programmausführung.
	   #+BEGIN_SRC cpp
	   int main() {
		   Code;
		   return 0;
	   }
	   #+END_SRC
	   - return aus der "main" Funktion ist optional
	 - Regel von c++ für erlaubte Name
	   - erstes Zeichen: Klein- oder Großbuchstaben des englischen Alphabets, oder "_"
	   - optional: weitere Zeichen oder, "_" oder Ziffer 0-9
	 - vordefinierte Funktionen:
	   - eingebaute $\estimates$ immer vorhanden
		 - Infix-Operatoren $+,-,*,/,\%$
		 - Prefix-Operatoren $operator+,operator-,\ldots$
	   - Funktion der Standardbibilothek $\estimates$ müssen "angefordert" werden
		 - Namen beginnen mit "std::", "std::sin,..."
		 - sind in Module geordnet, zum Beispiel
		   - cmath \Rightarrow algebraische Funktion
		   - complex \Rightarrow komplexe Zahlen
		   - string \Rightarrow Zeichenkettenverarbeitung
		 - um ein Modul zu benutzen muss man zuerst (am Anfang des Programms) sein Inhaltsverzeichnis importieren (Header includieren) $\rightarrow$ include <name>
		   #+BEGIN_SRC cpp
		   #include <iostream>
		   #include <string>
		   int main() {
			   std::cout << "Hello, world!" << std::endl;
			   std::string out = "mein erstes Programm\n";
			   std::cout << out;
			   return 0;
		   }
		   #+END_SRC
	 - overloading der arithmetischen Operationene
	   - overloading genau wie bei $sq$
		 - 3 * 4 \Rightarrow int Variante
		 - 3.0 * 4.0 \Rightarrow double Variante
		 - 3 * 4.0 \Rightarrow automatische Umwandliung in höheren Typ, hier "double" \Rightarrow wird als 3.0 * 4.0 ausgeführt
	 - \Rightarrow Devision unterscheidet sich
	   - Integer-Division: 12 / 5 = 2 (wird abgerundet)
	   - Double-Division: 12.0 / 5.0 = 2.4
	   - -12 / 5 = 2 (\Rightarrow truncated Division)
	   - 12.0 / 5.0 = 2.4
	   - Gegensatz (zum Beispiel in Python)
		 - floor division \Rightarrow wird immer abgerundet \Rightarrow -12 / 4 = -2
* Prozedurale Programmierung
** Von der Funktionalen zur prozeduralen Programmierung
   - Eigenschaften der Funktionalen Programmierung:
	 - alle Berechnungen durch Funktionsaufruf, Ergebnis ist Rückgabe
	 - Ergebnis hängt nur von den Werten der Funktionsargumente ab, nicht von externen Faktoren "referentielle Integrität"
	 - Speicherzellen für Zwischenergebnisse und Argumente können nach Initialisierung nicht geändert werden "write once"
	 - Möglichkeit rekusiver Funktionsaufrufe (jeder Aufruf bekommt eigene Speicherzellen)
	   - Vorteile
		 - natürliche Ausdrucksweise für arithmetische und algebraische Funktionaliät ("Taschenrechner")
		 - einfache Auswertung durch Substitutionsmodell \rightarrow Auswertungsreihenfolge nach Post-Order
		 - mathematisch gut formalisierbar \Rightarrow Korrektheitsbeweise, besonders bei Parallelverarbeitung
		 - Rekursion ist mächtig und natürliche für bestimmte Probleme (Fakutlät, Baumtraversierung)
	   - Nachteile
		 - viele Probleme lassen sich anders natürlicher ausdrücken (z.B. Rekursion vs. Iteration)
		 - setzt unendlich viel Speicher voraus (\Rightarrow Memory management notwendig \Rightarrow später)
		 - Entitäten, die sich zeitlich verändern schwer zu modellieren
	   - Korrolar: kann keine externen Resourcen (z.B. Konsole, Drucker, \ldots, Bildschirm) ansprechen "keine Seiteneffekte"
		 - \Rightarrow Multi-Paradigmen-Sprachen, zum Beispiel Kombination von Funktionaler Programmierung und prozeduraler Programmierung
** Kennzeichen
*** Prozeduren
   - Prozeduren: Funktionen, die nichts zurückgeben, haben nur Seiteneffekte
	 - Beispiel
	   #+BEGIN_SRC cpp
	   std::cout << "Hello\n"; // Infix
	   operator<<(std::cout, "Hello\n"; // Prefix
	   #+END_SRC
	 - Prozeduren in c++
	   1. Funktion die "void" zurückgibt (Pseudotyp für "nichts")
		  #+BEGIN_SRC cpp
		  void foo(int x) {
			  return;
		  }
		  #+END_SRC
	   2. Returnwert ignorieren
*** Steuerung des Programmablaufs
	 - Anweisungen zur Steuerung des Programmablaufs
	   #+BEGIN_SRC cpp
	   if(), else, while(), for()
	   #+END_SRC
	   - Funktional
		 #+BEGIN_SRC cpp
		 int abs(int x) {
			 return (x >= 0) ? x : -x;
		 }
		 #+END_SRC
	   - Prozedural
		 #+BEGIN_SRC cpp
		   int abs(int x) {
			   if(x >= 0) {
				   return x;
			   } else {
				   return -x;
			   }

			   // oder
			   if(x >= 0) return x;
			   return -x;
		   }
		 #+END_SRC
*** Veränderung von Speicherzellen
	 - Zuweisung: Speicherzellen können nachträglich verändert werden ("read-write")
	   - prozedural:
		 #+BEGIN_SRC cpp
		 int foo(int x) {     // x = 3
			 int y = 2;
			 int z1 = x * y;  // z1 = 6
			 y = 5;
			 int z2 = z * y;  // z2 = 15
			 return z1 + z2;  // 21
		 }
		 #+END_SRC
	   - funktional:
		 #+BEGIN_SRC cpp
		 int foo(int x) {     // x = 3
			 int y1 = 2;
			 int z1 = x * y;  // z1 = 6
			 int y2 = 5;
			 int z2 = z * y;  // z2 = 15
			 return z1 + z2;  // 21
		 }
		 #+END_SRC
	   - Syntax
		 #+BEGIN_SRC cpp
		 name = neuer_wert;           // Zuweisung
		 typ name = neuer_wert;       // Initialisierung
		 typ const name = neuer_wert; // write once
		 #+END_SRC
	   - \Rightarrow Folgen: mächtiger, aber ermöglicht völlig neue Bugs \Rightarrow erhöhte Aufmerksamkeit beim Programmieren
		 - die Reihenfolge der Ausführung ist viel kritischer als beim Substitutionsmodell
		 - Programmierer muss immer ein mentales Bild des aktuellen Systemzustans haben
*** Schleifen
	Der gleiche Code soll oft wiederholt werden
	#+BEGIN_SRC cpp
	while(bedingung) {
		// code, wird ausgeführt solange Bedingung "true"
	}
	#+END_SRC
	#+BEGIN_SRC cpp
	int counter = 0;
	while(counter < 3) {
		std::cout << counter << std::endl;
		counter++; // Kurzform für counter = counter + 1
	}
	#+END_SRC
	| counter | Bedingung |     Ausgabe |
	|---------+-----------+-------------|
	|       0 | true      |           0 |
	|       1 | true      |           1 |
	|       2 | true      |           2 |
	|       3 | false     | $\emptyset$ |

	- in c++ beginnt Zählung meist mit $0$ ("zero based")
	- vergisst man Inkrementierung \Rightarrow Bedingung immer "true" \Rightarrow Endlosschleife \Rightarrow Bug
	- drei äquivalente Schreibweisen für Inkrementierung:
	  - counter = counter + 1; // assignment $\estimates$ Zuweisung
	  - counter += 1;          // add-assignment $\estimates$ Abbkürzung
	  - ++counter;             // pre-increment
*** prozedurale Wurzelberechung
**** Ziel
	 #+BEGIN_SRC cpp
	 double sqrt(double y);
	 #+END_SRC
**** Methode
	 iterative Verbesserung mittel Newtonverfahren
	 initial_guess $x^{(0)}$ ("geraten"), t = 0 \\
	 while not_good_enough($x^{(t)}$): \\
		 update $x^{(t + 1)}$ from $x^{(t)}$ (zum Beispiel $x^{(t + 1)} = x^{(x)} + \Delta^{(t)}$ additives update, $x^{(t + 1)} = x^{(t)}\Delta^{(t)}$ multiplikatives update) \\
		 t = t + 1 \\
***** Newtonverfahren
	  Finde Nullstellen einer gegebenen Funktion $f(x)$, das heißt suche $x^\ast$ sodass $f(x^\ast) = 0$ oder $\abs{f(x^\ast)} < \varepsilon$
	  Taylorreihe von $f(x)$:, $f(x + \Delta) \approx f(x) + f'(x)\Delta +$ setze $x^\ast = x + \Delta$
	  \[0 \overset{!}{=} f(x^\ast) \approx f(x) + f'(x)\Delta = 0 \Rightarrow \Delta = - \frac{f(x)}{f'(x)}\]
	  Iteratiosvorschrift:
	  \[x^{(t + 1)} = x^{(t)} - \frac{f(x^{(\ast)})}{f'(x^{(\ast)})}\]
	  Anwendung auf Wurzel: setze $f(x) = x^2 - y \Rightarrow$ mit $f(x^\ast) = 0$ gilt
	  \[(x^\ast)^2 -y = 0 \quad (x^\ast)^2 = y \quad x^\ast = \sqrt{y}\quad f'(x) = 2x)\]
	  Iterationsvorschrieft:
	  \[x^{(t + 1)} = x^{(t)} - \frac{(x^{(t)^2}) - y}{2x^{(t)}} = \frac{x^{(t)^2} + y}{2x^{(t)}}\]
	  #+BEGIN_SRC cpp
		double sqrt(double y) {
		  if(y < 0.0) {
			  std::cout << "Wurzel aus negativer Zahl\n";
			  return -1.0;
			}
			if(y == 0.0) return 0.0;

			double x = y; // inital guess
			double epsilon = 1e-15 * y;

			while(abs(x * x - y) > epsilon) {
				x = 0.5*(x + y / x);
			}
		}
	  #+END_SRC
*** for-Schleife
	#+BEGIN_SRC cpp
	int c = 0;
	while(c < 3) {
		// unser code
		c++; // vergisst man leicht
    }
	#+END_SRC

	Bei der while Schleife kann man leicht vergessen $c$ zu inkrementieren, die for Schleife ist idiotensicher \\
	Äquivalent zu der while Schleife oben ist:
	#+BEGIN_SRC cpp
	for(int c = 0; c < 3; c++) {
		// unser code
	}
	#+END_SRC

	Allgemeine Form:
	#+BEGIN_SRC cpp
	for(init; Bedingung; Inkrement) {
		// unser code
	}
	#+END_SRC
	- Befehle, um Schleifen vorzeitig abzubrechen
	  - continue: Bricht aktuelle Iteration ab und springt zum Scleifenkpf
	  - break: bbricht ganz Schleife ab und springt hinter das Schleifenende
	  - return: beednet Funktion und auch die Schleife
	Beispiel: nur gerade Zahlen ausgeben
	#+BEGIN_SRC cpp
	for(int i = 0; i < 10; i++) if(c % 2 == 0) std::cout << c << std::endl;
	#+END_SRC
	Variante mit continue:
	#+BEGIN_SRC cpp
	for(int i = 0; i < 10; i++) {
		if(c % 2 != 0) continue;
		std::cout << c << std::endl;
	}
	#+END_SRC

	#+BEGIN_SRC cpp
	for(int i = 0; i < 10; i += 2) {
		std::cout << c << std::endl;
	}
	#+END_SRC
	#+BEGIN_SRC cpp
	double sqrt(double y) {
		while(true) {
			x = (x + y / 2) / 2.0;
			if(abs(x * x - y) < epsilon) {
				return x;
			}
		}
	}
	#+END_SRC

* Datentypen
** Basistypen
   Bestandteil der Sprachsyntax und normalerweise direkt von der Hardware unterstützt (CPU)
   - int, double, bool ($\Rightarrow$ später mehr)
** zusammengesetzte Typen
   mit Hilfe von "struct" oder "class" aus einfachen Typen zusammengesetzt
   - wie das geht $\Rightarrow$ später
   - Standardtypen: in der C++ Standardbibilothek definiert, aktivire durch $\#include <module_name>$
	 - std::string, std::complex, etc.
   - externe Typen: aus anderer Bibilothek, die manzuvor herunterladen und installieren muss
   - eigene Typen: vom Programmierer selbst implementiert $\Rightarrow$ später
   Durch "objekt-orientierte Programmierung" (\Rightarrow später) erreicht man, dass zusammengesetzte Typen genauso einfach und bequem und effizient sind wie Basistypen (nur c++, nicht c)
   - "Kapselung": die interne Struktur und Implementation ist für Benutzer unsichtbar
   - Benutzer manipuliert Speicher über Funktionen ("member functions") $\estimates$ Schnittstelle des Typs, "Interface", API

   \Rightarrow Punktsyntax: type_name t = init; t.foo(a1, a2); $\estimates$ foo(t, a1, a2);
** Zeichenketten-Strings:
   zwei Datentypen in c++
   - klassischer c-string: char[] ("charakter array") \Rightarrow nicht gekapselt, umständlich
   - c++ string: std::string gekapselt und bequem (nur dieser in der Vorlesung)
   - string literale: "zeichekette", einzelnes Zeichen: 'z' ("z" = Kette der Länge 1) \\
	 Vorsicht: die String-Literale sind c-strings (gibt keine c++ string-Literale), müssen erst in c++ strings umgewandelt werden, das passiert mist automatisch
	 - #include <string>
	 - Initialisierung:
	   #+BEGIN_SRC cpp
	   std::string s = "abcde";
	   std::string s2 = s1;
	   std::string leer = "";
	   std::string leer(); // Abkürzung, default constructor
	   #+END_SRC
	 - Länge
	   #+BEGIN_SRC cpp
	   s.size();
	   assert(s.size() == 5);
	   assert(leer.size() == 0);
	   s.empty() // Abkürzung für s.size() == 0
	   #+END_SRC
	 - Zuweisung
	   #+BEGIN_SRC cpp
	   s = "xy";
	   s2 = leer;
	   #+END_SRC
	 - Addition
	   Aneinanderkettung von String ("concatenate")
	   #+BEGIN_SRC cpp
	   std::string s3 = s + "ijh"; // "xyijh"
	   s3 = "ghi" + s; // "ghixy"
	   s3 = s + s; // "xyxy"
	   // aber nicht!!
	   s3 = "abc" + "def"; // Bug literale unterstütze + mit ganz anderer Bedeutung
	   s3 = std::string("abc") + "def"; // Ok
	   #+END_SRC
	 - Add-Assignment: Abkürzung für Addition gefolt von Zuweisung
	   #+BEGIN_SRC cpp
	   s += "nmk"; // s = s + "nmk" => "xynmk"
	   #+END_SRC
	 - die Zeichen werden intern in einem C-Array gespeichert (Array = "Feld") \\
	   Array: zusammenhängende Folge von Speicherzellen des gleichen Typs, hier 'char' (für einzelne Zeichen), Die Länge wird (bei std::string) automatisch angepasst, die einzelnen Speicherzellen sind durchnummerriert
	   in c++: von $0$ beginnend $\estimates$ Index
	   - Indexoperator:
		 #+BEGIN_SRC cpp
		 s[index]; // gibt das Zeichen an Position "index" zurück
		 #+END_SRC
		 Anwendung: jedes Zeichen einzeln ausgeben
		 #+BEGIN_SRC cpp
		 std::string s = "abcde";

		 for(int i = 0; i < s.size(); i++) {
			 std::cout << s[i] << std::endl;
		 }
		 #+END_SRC
		 String umkehren
		 #+BEGIN_SRC cpp
		 int i = 0; // Anfang des Strings
		 int k = s.size() - 1; // Ende des String
		 while(i < k) {
			 char tmp = s[i];
			 s[i] = s[k];
			 s[k] = tmp;
			 i++; k--;
		 }
		 #+END_SRC
		 Variante 2: neuen String erzeugen
		 #+BEGIN_SRC cpp
		 std::string s = "abcde";
		 std::string r = "";
		 for(int i = s.size() - 1; i >= 0; i--) {
			 r += s[i];
		 }
		 #+END_SRC
* Umgebungsmodell
  Gegenstück zum Substitutionsmodell (in der funktionalen Programmierung) für die prozedurale Programmierung
  - Regeln für Auswertung von Audrücken
  - Regeln für automatische Speicherverwaltung
	- Freigeben nicht mehr benötigter Speicherzellen, \Rightarrow bessere Approximation von "unendlich viel Speicher"
  - Umgebung beginnt normalerweise bei "{" und endet bei "}" \\
	Ausnahmen:
	- $for$: Umgebung beginnt schon bei "for" \Rightarrow Laufvariable ist Teil der Umgebung
	- Funktionsdefinitionen: Umgebung beginnt beim Funktionskopf \Rightarrow Speicherzellen fpr Argumente und Ergebnis gehören zur Umgebung
	- globale Umgebung außerhalb aller "{ }" klammern
  - automatische Speiccherverwaltung
	- Speicherzellen, die in einer Umgebung angelegt werde (initialisiert, deklariert) werde, am Ende der Umgebung in umgekehrter Reihenfolge freigegeben
	- Computer fügt vor "}" automatisch die Notwendigen Befehle ein
	- Speicherzellen in der globalen Umgebung werden am Programmende freigegeben
	  #+BEGIN_SRC cpp
	- int global = 1;
	  int main() {
		  int l = 2;
		  {
			  int m = 3
		  } // <- m wird freigegeben
	  } // <- l wird freigegeben
	  // <- global wird freigegeben
	  #+END_SRC
  - Umgebungen können beliebig geschachtelt werden \Rightarrow alle Umgebungen bilden einen Baum, mit der globalen Umgebung als Wurzel
  - Funktionen sind in der globalen Umgebung definiert
	- Umgebung jeder Funktion sind Kindknoten der globalen Umgebung (Ausnahme: Namensräume \Rightarrow siehe unten) \\
	  \Rightarrow Funktions Umgebung ist *nicht* in der Umgebung, wo die Funktion aufgerufen wird
  - Jede Umgebung besitzt eine *Zuordungstabelle* für alle Speicherzellen, die in der Umgebung definiert wurden
	| Name | Typ | aktueller Wert |
	|------+-----+----------------|
	| l    | int | 2              |
  - jeder Name kann pro Umgebung nur einmal vorkommen
  - Ausnahme Funktionsnamen können mehrmals vorkommen bei function overloading (nur c++)
  - Alle Befehle werden relativ zur aktuellen Umgebung ausgeführt
	- aktuell: Zuordungstabelle der gleichen Umgebung und aktueller Wert zum Zeitpunkt des Aufrufs \\
	  Beispiel: $c = a * b;$ \\
	  Regeln:
	- wird der Name (nur $a, b, c$) in der aktuellen Zuordungstabelle gefunden
	  1. Typprüfung \Rightarrow Fehlermeldung, wenn Typ und Operation nicht zusammenpassen
	  2. andernfalls, setze aktuellen Wert aus Tabelle in Ausdruch ein (ähnlich Substitutionsmodell)
	- wird Name nicht gefunden: suche in der Elternumgebung weiter
	- wir der Name bis zur Wurzel (gloable Umgebung) nicht gefunden \Rightarrow Fehlermeldung
	- \Rightarrow ist der Nme in mehreren Umgebungen vorhanden gild as zerst gefundene (Typ, Wert)
  - \Rightarrow Programmierrer muss selbst darauf achten, ass
	1. bei der Suche die gewünschte Spicherzelle gefunden wird \Rightarrow beutze "sprechende Namen"
	2. der aktuelle Wert der richtig ist \Rightarrow beachte Reihenfolge der Befehle!
  - Namensraum: spezielle Umgebungen in der globalen Umgebung (auch geschachtelt) mit einem Namen \\
	Ziele:
	- Gruppieren ovn Funktionalität in Module (zusätzlich zu Headern)
	- verhinderung von Namenskollisionen

	Beispiel: c++ Standardbibilothek:
	#+BEGIN_SRC cpp
	namespace std {
	double sqrt(double x);
	namespace chrono {
	class system_clock;
	}
	}

	// Benutzung mit Namespace-Prefix:
	std::sqrt(80);
	std::chrono::system_clock clock;
	#+END_SRC
	Besonderheit: mehrere Blöcke mit selbem Namensraum werden verschmolzen
   Beispiel
   #+BEGIN_SRC cpp
   int p = 2;
   int q = 3;

   int foo(int p) {
	   return p * q;
   }

   int main() {
	   int k = p * q; // beides global => 6 = 2 * 3
	   int p = 4; // lokales p verdeckt globales p
	   int r = p * q; // p lokal, q global => 12 = 4 * 3
	   int s = foo(p); // lokale p von main() wird zum lokalen p von foo() 12 = 4 * 3
	   int t = foo(q); // globales q wird zum lokalen p von foo() 9 = 3 * 3
	   int q = 5;
	   int n = foo(g); // lokales q wird zum lokalen p von foo() 15 = 5 * 3
   }
   #+END_SRC
* Referenzen
  sind neue (zusätzliche) Namen für vorhandene Speicherzellen
   #+BEGIN_SRC cpp
   int x = 3; // neue Variable x mit neuer Speicherzell
   int & y = x; // Referenz: y ist neuer Name für x, beide haben die selbe Speicherzelle
   y = 4; // Zuweisung an y, aber x ändert sich auch, das heißt x == 4
   x = 5; // jetzt y == 5
   int const & z = x; // read-only Referenz, das heißt z = 6 ist verboten
   x = 6; // jetzt auch z == 6
   #+END_SRC
  Hauptanwendung:
  - die Umgebung, wo eine Funktion aufgerufen wird und die Umgebung der Implementation sind unabhängig, das heißt Variablen der einen Umgebung sind in der anderen nicht sichtbar
  - häuftig möchte man Speicherzellen in beidel Umgebungen teilen \Rightarrow verwende Referenzen
  - häufig will man vermeiden, dass eine Variable kopiert wird (pass-by-value)
	- Durch pass-by-reference brauch man keine Kopie \Rightarrow typisch "const &", also read-only, keine Seiteneffekte
	 #+BEGIN_SRC cpp
	 int foo(int x) { // pass-by-value
		 x += 3;
		 return x;
	 }

	 int var(int & y) { // pass-by-reference
		 y += 3; // Seiteneffekt der Funktion
		 return y;
	 }

	 void baz(int & z) { // pass-by-reference
		 z += 3;
	 }

	 int main() {
		 int a = 3;
		 std::cout << foo(a) << std::endl; // 5
		 std::cout << a << std::endl; // 2
		 std::cout << bar(a) << std::endl; // 5
		 std::cout << a << std::endl; // 5
		 baz(a);
		 std::cout << a << std::endl; // 8
	 }
	 #+END_SRC
	 in der funktionalen Programmierungt sind Seiteneffekte grundsätzlich verboten, mit Ausnahmen, zum Beispiel für Ein-/Ausgabe
* Container-Datentypen
  Dienen dazu, andere Daten aufzubewahren
  - Art der Elemente:
	- homogene Container: alle Elemente haben gleichen Type (typisch für c++)
	- heterogene Container: Elemente könne verschiedene Typen haben (z.B. Python)
  - nach Größen
	- statische Container: feste Größe, zur Compilezeit bekannt
	- dynamische Container: Größe zur Laufzeit veränderbar
  - Arrays sind die wichtigsten Container, weil effizient auf Hardware abgebildet und einfach zu benutzen
	- klassisch: Arrays sind statisch, zum Beispiel C-Arrays (hat c++ geerbt)
	 #+BEGIN_SRC cpp
	 int a[20];
	 #+END_SRC
	- modern: dynamische Arrays
	  - Entdeckung einer effizienten Implementation
	  - Kapselung durch objekt-orientierte Programmierung (sonst zu kompliziert)
  - wir kennen bereits ein dynamisches Array: std::string ist Abbildung int (Index) \rightarrow char (Zeichen), mit $0 \leq~\text{index}~ < ~\text{s.size()}$
	- wichtigste Funktion: s.size() (weil Größe dynamisch), s[4 ] Indexzugriff, s+="mehr" Zeichen anhängen
  - wir wollen das selbe Verhalten für beliebige Elementtypen:
	 #+BEGIN_SRC cpp
	 #include <vector>

	 //          Elementtyp    Größe  Initialwert der Elemente
	 std::vector<double    > v(20   ,           0.0           );
	 // analog
	 std::vector<int>;
	 std::vector<std::string>;
	 #+END_SRC
  - weitere Verallgemeinerung: Indextyp beliebig (man sagt dann "Schlüssel-Typ") "assoziatives Array"
	- typische Fälle:
	  - Index ist nicht im Bereich (0,size], zum Beispiel Matrikelnummern
	  - Index ist string, zum Beispiel Name eines Studenten
		#+BEGIN_SRC cpp
		#include <map>
		#include <unordered_map>

		// Binärer Suchbaum
		std::map;

		// Hashtabelle, siehe Algorithmen und Datenstrukturen
		std::unordered_map;

		//       Schlüsseltyp  Elementtyp
		std::map<int         , double> noten; noten[3121101] = 10;
		std::map<std::string, double> noten; noten["krause"] = 10;
		#+END_SRC
	  - Indexoperationen wie beim Array
	  - Elemente werden beim 1. Zugriff automatisch erzeugt (dynamisch)
  - alle dynamischen und assoziativen Arrays unterstützen a.size() zum Abfragen der Grlße
** std::vector
   - Erzeugen:
	 #+BEGIN_SRC cpp
	 std::vector<double> v(20, 1.0);
	 std::vector<double> v; // leeres Array
	 std::vector<double> v = {1.0, -3.0, 2.2}; // "initializer list": Element für Anfangszustand
	 #+END_SRC
   - Größe:
	 #+BEGIN_SRC cpp
	 v.size();
	 v.empty(); // => v.size() == 0
	 #+END_SRC
   - Größe ändern
	 #+BEGIN_SRC cpp
	 v.resize(neue_groesse, initialwert);
	 // Dann:
	 // Fall 1: neue_groesse < size(): Element ab Index "neue_groesse" gelöscht die andern bleiben
	 // Fall 2: neue_groesse > size(): neue Elemente mit Initialwert am Ende anhängen, die anderen bleiben
	 // Fall 3: neue_groesse == size(): nichts passiert

	 v.push_back(neues_element); // ein neues Element am Ende anhängen (ähnlich string += "mehr")
	 v.insert(v.begin() + index, neues_element); // neues element an Position "index" einfügen 0 <= index <= size()
	 // Falls index == size(): am Ende anhängen, sonst: alte Elemente ab Index werden eine Position nach hinten verschoben (teuer)

	 v.pop_back(); // letzes Element löschen (effizient)
	 v.erase(v.begin() + index); // Element an Pos index löschen, alles dahinter eine Position verschieben (teuer)
	 v.clear(); // alles löschen
	 #+END_SRC
   - Zugriff
	 #+BEGIN_SRC cpp
	 v[k]; // Element bei Index k
	 v.at(k); // wie v[k], aber Fehlermeldung, wenn nicht 0 <= k < size() (zum Debuggen)
	 #+END_SRC
   - Funktionen für Container benutzen in c++ immer Iteratoren, damit sie für verschiedene Container funktionieren
	 - Iterator-Range
	   #+BEGIN_SRC cpp
	   // erstes Element
	   v.begin()

	   // hinter letztem Element
	   v.end()
	   #+END_SRC
	 - im Header <algorithm>
	 - alle Elemente kopieren
	   #+BEGIN_SRC cpp
	   std::vector<double> source = {1.0, 2, 3, 4, 5};
	   std::vector<double> target(source.size(), 0.0);
	   std::copy(source.begin(), source.end(), target.begin());
	   std::copy(source.begin() + 2, source.end() - 1, target.begin()); // nur index 2 .. size() - 1 kopieren
	   #+END_SRC
	 - Elemente sortieren
	   #+BEGIN_SRC cpp
	   std::sort(v.begin(), v.end()); // "in-place" sortieren
	   #+END_SRC
	 - Elemente mischen:
	   #+BEGIN_SRC cpp
	   std::random_shuffle(v.begin(), v.end()); "in-place" mischen
	   #+END_SRC
