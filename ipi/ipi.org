#+AUTHOR: Robin Heinemann
#+TITLE: Einführung in die Anwendungsorientierte Informatik (Köthe)
#+OPTIONS: H:6
#+LATEX_CLASS: koma-article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage{siunitx}%
#+LATEX_HEADER: \usepackage{fontspec}%
#+LATEX_HEADER: \sisetup{load-configurations = abbrevations}%
#+LATEX_HEADER: \newcommand{\estimates}{\overset{\scriptscriptstyle\wedge}{=}}%
#+LATEX_HEADER: \usepackage{mathtools}%
#+LATEX_HEADER: \DeclarePairedDelimiter\abs{\lvert}{\rvert}%
#+LATEX_HEADER: \DeclarePairedDelimiter\norm{\lVert}{\rVert}%
#+LATEX_HEADER: \DeclareMathOperator{\Exists}{\exists}%
#+LATEX_HEADER: \DeclareMathOperator{\Forall}{\forall}%
#+LATEX_HEADER: \def\colvec#1{\left(\vcenter{\halign{\hfil$##$\hfil\cr \colvecA#1;;}}\right)}
#+LATEX_HEADER: \def\colvecA#1;{\if;#1;\else #1\cr \expandafter \colvecA \fi}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{makecell}
# #+LATEX_HEADER: \usemintedstyle{tango}
#+LATEX_HEADER: \usemintedstyle{perldoc}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{arrows,automata}
#+LATEX_HEADER: \usepackage{tikz-qtree}
#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \setlistdepth{20}
#+LATEX_HEADER: \renewlist{itemize}{itemize}{20}
#+LATEX_HEADER: \setlist[itemize]{label=$\cdot$}

# #+BEGIN_SRC cpp
# for(int i = 0; i < 5) {
#    std::cout << i << std::endl;
# }
# #+END_SRC

#+INCLUDE: "/home/robin/study/lectures/ipi/introduction.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/differences.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/differences.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/substitution_model.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/machine_code.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/functional_programming.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/procedural_programming.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/datatypes.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/stack_model.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/references.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/container.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/itertators.org" :minlevel 1

* Insertion Sort
  schnellster Sortieralgorithmus für kleine Arrays ($n\leq 30$) hängt von Compiler und CPU ab
  - Idee von Insertion Sort:
	- wie beim Aufnehmen und Ordnen eines Kartenblatts
	- gegeben: bereits sortierte Teilmenge bis Position $k - 1$ Karten bereits in Fächer
	- Einfügen des k-ten Elements an richtiger Stelle \rightarrow Erzeuge Lücke an richtiger Position duch verschieben von Elementen nach rechts
	- Wiederholung für $k = 1, \ldots, N$
	- Bespiel:
	  | 4 | 2 | 3 | 5 | 1 |
	  |---+---+---+---+---|
	  | 4 | _ | 3 | 5 | 1 |
	  | _ | 4 | 3 | 5 | 1 |
	  | 2 | 4 | 3 | 5 | 1 |
	  |---+---+---+---+---|
	  | 2 | 4 | _ | 5 | 1 |
	  | 2 | _ | 4 | 5 | 1 |
	  | 2 | 3 | 4 | 5 | 1 |
	  |---+---+---+---+---|
	  | 2 | 3 | 4 | _ | 1 |
	  | 2 | 3 | 4 | 5 | 1 |
	  |---+---+---+---+---|
	  | 2 | 3 | 4 | 5 | _ |
	  | _ | 2 | 3 | 4 | 5 |
	  | 1 | 2 | 3 | 4 | 5 |
	  #+BEGIN_SRC cpp
	  void insertion_sort(std::vector<double> & v) {
		  for(int i = 0; i < v.size(); i++) {
			  double current = v[i];
			  int j = i; // Anfangsposition der Lücke
			  while(j > 0) {
				  if(v[j - 1] < current) { // -> if(cmp(a, b))
					  break; // j ist richtige Position der Lücke
				  }
				  v[j] = v[j - 1];
				  j--;
			  }
			  v[j] = current;
		  }
	  }
	  #+END_SRC
	- andere Sortierung: definiere Funktor cmp(a, b), der das gewüschte kleiner realisiert (gibt genau dann "true" zurück, wenn a "kleiner" b nach neuer Sortierung)
	- neue Sortierung am besten per Lambda-Funktion an std::sort übergeben
	  #+BEGIN_SRC cpp
	  std::sort(v.begin(), v.end()); // Standartsort mit "<"
	  std::sort(v.begin(), v.end(), [](double a, double b) { return a < b; }); // Standardsortierung aufsteigen
	  std::sort(v.begin(), v.end(), [](double a, double b) { return b < a; }); // absteigende Sortierung
	  std::sort(v.begin(), v.end(), [](double a, double b) { return std::abs(a) < std::abs(b); }); // Normal nach Betrag; // Normal nach Betrag
	  std::sort(v.begin(), v.end(), [](std::string a, std::string b) {
		  std::transform(a.begin(), a.end(), a.begin(), std::tolower);
		  std::transform(b.begin(), b.end(), b.begin(), std::tolower);
		  return a < b;
	  });
	  #+END_SRC
* generische Programmierung
  insertion\_sort soll für beliebige Elementtypen funktionieren
  #+BEGIN_SRC cpp
	  template<typename T>
	  void insertion_sort(std::vector<T> & v) {
		  for(int i = 0; i < v.size(); i++) {
			  T current = v[i];
			  int j = i; // Anfangsposition der Lücke
			  while(j > 0) {
				  if(v[j - 1] < current) { // -> if(cmp(a, b))
					  break; // j ist richtige Position der Lücke
				  }
				  v[j] = v[j - 1];
				  j--;
			  }
			  v[j] = current;
		  }
	  }
  #+END_SRC
  - Ziel: benutze template-Mechanismus, damit *eine* Implementation für viele verschiedene Typen verwendbar ist
	- erweitert funktionale und prozedurale und objekt-orientiere Programmierung
  - zwei Arten von Templates ("Schablone"):
	1. Klassen-templates für Datenstrukturen, zum Beispiel Container sollen beliebige Elementtypen unterstützen
	   - Implementation \implies später
	   - Benutzung: Datenstrukturname gefolgt vom Elementtyp in Spizen Klammern (std::vector<double>), oder mehrere Typen, zum Beispiel Schlüssel und Wert bei std::map<std::string, double>
	2. Funktionen-Templates: es gab schon function overloadingg
	   #+BEGIN_SRC cpp
	   int sq(int x) {
		   return x * x;
	   }

	   double sq(double x) {
		  return x * x;
	   }

	   // und so weiter für komplexe und rationale Zahlen...
	   #+END_SRC
	   - Nachteil
		 - wenn die Implementationen gleich sind \rightarrow nutzlose Arbeit
		 - Redundanz ist gefährlich: korrigiert man einen Bug wir leicht eine Variante vergessen
	   - mit templates reicht eine Implementation
		 #+BEGIN_SRC cpp
		 template<typename T> // T: Platzhalter für beliebigen Typ, wird später durch einen tatsächlichen Typ ersetzt
		 T sq(T x) {
			 return x * x; // implizierte Anforderung an den Typ T, er muss Multiplikation unterstützen, sonst: Fehlermeldung
		 }
		 #+END_SRC
		 - wie bei Substituieren von Variablen mit Werten, aber jetzt mit Typen
		 - Benutzug:
		   - Typen für die Platzhalter hinter dem Funktionsnamen in spitzen klammern
			 #+BEGIN_SRC cpp
			 sq<int>(2) == 4;
			 sq<double>(3.0) == 9.0,
			 #+END_SRC
		   - meist kann man die Typangabe <type> weglassen, weil der Computer sie anhand des Argumenttyps automatisch einsetzt:
			 #+BEGIN_SRC cpp
			 sq(2); // == sq<int>(2) == 4
			 sq(3.0); // == sq<double>(3.0) == 9
			 #+END_SRC
		   - kombiniert man templates mit Overloading, wird die ausprogrammierte Variante vom Compiler bevorzugt.
			 Komplizierte Fälle (Argument teilweise Template, teilweise hard_coded) \implies für Fortgeschrittene
		 - Beispiel 2: Funktion, die ein Array auf Konsole ausgibt, für beliebige Elementtypen
		   #+BEGIN_SRC cpp
		   template<typename ElementType>
		   void print_vector(std::vector<ElementType> const & v) {
			   std::cout << "{";
			   if(v.size() > 0) {
				   std::cout << " " << v[0];
				   for(int i = 1; i < v.size(); i++) {
					   std::cout << ", " << v[i];
				   }
			   }
			   std::cout << " }";
		   }
		   #+END_SRC
		 - Verallgemeinerung für beliebige Container mittel Iteratoren:
		   #+BEGIN_SRC cpp
		   std::list<int> l = {1, 2, 3};
		   print_containter(l.begin(), l.end()); // "{1,2,3}"
		   #+END_SRC
		 - es genügen forward_interators
		   #+BEGIN_SRC cpp
		   Iterator iter2 = iter1; // Kopie erzeugen
		   iter1++; // zum nächsten Element
		   iter1 == iter2; // Zeigen sie auf das selbe Element?
		   iter1 != end;
		   *iter1; // Zugrif auf aktuelles Element

		   template<typename Iterator>
		   void print_container(Iterator begin, Iterator end) {
			   std::cout << "{}";
			   if(begin != end) { // Container nicht leer?
				   std::cout << " " << *begin++;
				   for(;begin != end; begin++) {
					   std::cout << ", " << *begin;
				   }
			   std::cout << "}";
		   }
		   #+END_SRC
		 - Bespiel 3: checken, ob Container sortiert ist
		   #+BEGIN_SRC cpp
		   template<typename E, typename CMP>
		   bool check_sorted(std::vector<E> const & v, CMP less_than) {
			   for(int i = 1; i < v.size(); i++) {
				   if(less_than(v[k], v[k - 1])) { // statt v[k] < v[k - 1], ausnutzen der Transitivität
					   return false;
				   }
			   }
			   return true;
		   }

		   // Aufruf:
		   std::vector<double> v = {1.0, 2.0, 3.0};
		   check_sorted(v, [](double a, double b) { return a < b; } ); // == true

		   check_sorted(v, [](double a, double b) { return a > b; } ); // == false

		   // implementation für iteratoren
		   template<typename Iterator, typename CMP>
		   bool check_sorted(Iterator begin, Iterator end, CMP less_than) {
			   if(begin == end) {
				   return true;
			   }
			   Iterator next = begin;
			   ++next;
			   for(; next != end; ++begin, ++next) {
				   if(less_than(*next, *begin)) {
					   return false;
				   }
			   }
			   return true;
		   }
		   // == std::is_sorted
		   #+END_SRC
		 - Bemerkung1: Complier-Fehlermeldungen bei Template-Code sind oft schwer zu interpretieren, \implies Erfahrug nötig aber: Compiler werden darin immer besser, besonders clang-comiler
		 - mit Templatees kann man noch viel raffiniertere Dinge machen, zum Beispiel Traits-Klassen, intelligent libraries template meta programming \implies nur für Fortgeschrittene
