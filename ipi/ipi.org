#+AUTHOR: Robin Heinemann
#+TITLE: Einführung in die Anwendungsorientierte Informatik (Köthe)
#+OPTIONS: H:6
#+LATEX_CLASS: koma-article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage{siunitx}%
#+LATEX_HEADER: \usepackage{fontspec}%
#+LATEX_HEADER: \sisetup{load-configurations = abbrevations}%
#+LATEX_HEADER: \newcommand{\estimates}{\overset{\scriptscriptstyle\wedge}{=}}%
#+LATEX_HEADER: \usepackage{mathtools}%
#+LATEX_HEADER: \DeclarePairedDelimiter\abs{\lvert}{\rvert}%
#+LATEX_HEADER: \DeclarePairedDelimiter\norm{\lVert}{\rVert}%
#+LATEX_HEADER: \DeclareMathOperator{\Exists}{\exists}%
#+LATEX_HEADER: \DeclareMathOperator{\Forall}{\forall}%
#+LATEX_HEADER: \def\colvec#1{\left(\vcenter{\halign{\hfil$##$\hfil\cr \colvecA#1;;}}\right)}
#+LATEX_HEADER: \def\colvecA#1;{\if;#1;\else #1\cr \expandafter \colvecA \fi}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{makecell}
# #+LATEX_HEADER: \usemintedstyle{tango}
#+LATEX_HEADER: \usemintedstyle{perldoc}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{arrows,automata}
#+LATEX_HEADER: \usepackage{tikz-qtree}
#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \setlistdepth{20}
#+LATEX_HEADER: \renewlist{itemize}{itemize}{20}
#+LATEX_HEADER: \setlist[itemize]{label=$\cdot$}

# #+BEGIN_SRC cpp
# for(int i = 0; i < 5) {
#    std::cout << i << std::endl;
# }
# #+END_SRC

#+INCLUDE: "/home/robin/study/lectures/ipi/introduction.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/differences.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/differences.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/substitution_model.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/machine_code.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/functional_programming.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/procedural_programming.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/datatypes.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/stack_model.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/references.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/container.org" :minlevel 1
#+INCLUDE: "/home/robin/study/lectures/ipi/itertators.org" :minlevel 1

* Insertion Sort
  schnellster Sortieralgorithmus für kleine Arrays ($n\leq 30$) hängt von Compiler und CPU ab
  - Idee von Insertion Sort:
	- wie beim Aufnehmen und Ordnen eines Kartenblatts
	- gegeben: bereits sortierte Teilmenge bis Position $k - 1$ Karten bereits in Fächer
	- Einfügen des k-ten Elements an richtiger Stelle \rightarrow Erzeuge Lücke an richtiger Positin duch verschieben von Elementen nach rechts
	- Wiederholung für $k = 1, \ldots, N$
	- Bespiel:
	  | 4 | 2 | 3 | 5 | 1 |
	  |---+---+---+---+---|
	  | 4 | _ | 3 | 5 | 1 |
	  | _ | 4 | 3 | 5 | 1 |
	  | 2 | 4 | 3 | 5 | 1 |
	  |---+---+---+---+---|
	  | 2 | 4 | _ | 5 | 1 |
	  | 2 | _ | 4 | 5 | 1 |
	  | 2 | 3 | 4 | 5 | 1 |
	  |---+---+---+---+---|
	  | 2 | 3 | 4 | _ | 1 |
	  | 2 | 3 | 4 | 5 | 1 |
	  |---+---+---+---+---|
	  | 2 | 3 | 4 | 5 | _ |
	  | _ | 2 | 3 | 4 | 5 |
	  | 1 | 2 | 3 | 4 | 5 |
	  #+BEGIN_SRC cpp
	  void insertion_sort(std::vector<double & v) {
		  for(int i = 0; i < v.size(); i++) {
			  double current = v[i];
			  int j = i; // Anfangsposition der Lücke
			  while(j > 0) {
				  if(v[j - 1] < current) { // -> if(cmp(a, b))
					  break; // j ist richtige Position der Lücke
				  }
				  v[j] = v[j - 1];
				  j--;
			  }
			  v[j] = current;
		  }
	  }
	  #+END_SRC
	- andere Sortierung: definiere Funktor cmp(a, b), der das gewüschte kleiner realisiert (gibt genau dann "true" zurück, wenn a "kleiner" b nach neuer Sortierung)
	- neue Sortierung am besten per Lambda-Funktion an std::sort übergeben
	  #+BEGIN_SRC cpp
	  std::sort(v.begin(), v.end()); // Standartsort mit "<"
	  std::sort(v.begin(), v.end(), [](double a, double b) { return a < b; }); // Standardsortierung aufsteigen
	  std::sort(v.begin(), v.end(), [](double a, double b) { return b < a; }); // absteigende Sortierung
	  std::sort(v.begin(), v.end(), [](double a, double b) { return std::abs(a) < std::abs(b); }); // Normal nach Betrag; // Normal nach Betrag
	  std::sort(v.begin(), v.end(), [](std::string a, std::string b) {
		  std::transform(a.begin(), a.end(), a.begin(), std::tolower);
		  std::transform(b.begin(), b.end(), b.begin(), std::tolower);
		  return a < b;
	  });
	  #+END_SRC
* templates
  insertion_sort soll für beliebige Elementtypen funktionieren
  #+BEGIN_SRC cpp
	  void insertion_sort(std::vector<double & v) {
		  for(int i = 0; i < v.size(); i++) {
			  double current = v[i];
			  int j = i; // Anfangsposition der Lücke
			  while(j > 0) {
				  if(v[j - 1] < current) { // -> if(cmp(a, b))
					  break; // j ist richtige Position der Lücke
				  }
				  v[j] = v[j - 1];
				  j--;
			  }
			  v[j] = current;
		  }
	  }
  #+END_SRC
