% Created 2016-12-07 Mi 02:08
\documentclass[a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{siunitx}%
\usepackage{fontspec}%
\sisetup{load-configurations = abbrevations}%
\newcommand{\estimates}{\overset{\scriptscriptstyle\wedge}{=}}%
\usepackage{mathtools}%
\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\DeclarePairedDelimiter\norm{\lVert}{\rVert}%
\DeclareMathOperator{\Exists}{\exists}%
\DeclareMathOperator{\Forall}{\forall}%
\def\colvec#1{\left(\vcenter{\halign{\hfil$##$\hfil\cr \colvecA#1;;}}\right)}
\def\colvecA#1;{\if;#1;\else #1\cr \expandafter \colvecA \fi}
\usepackage{minted}
\usepackage{makecell}
\usemintedstyle{perldoc}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{tikz-qtree}
\usepackage{enumitem}
\setlistdepth{20}
\renewlist{itemize}{itemize}{20}
\setlist[itemize]{label=$\cdot$}
\author{Robin Heinemann}
\date{\today}
\title{Einführung in die Anwendungsorientierte Informatik (Köthe)}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 25.1.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\tableofcontents


\section{Was ist Informatik?}
\label{sec-1}
"Kunst" Aufgaben mit Computerprogrammen zu lösen.
\subsection{Teilgebiete}
\label{sec-1-1}
\subsubsection{theoretische Informatik (\textbf{ITH})}
\label{sec-1-1-1}
\begin{itemize}
\item Berechenbarkeit: Welche Probleme kann man mit Informatik lösen und welche prinzipiell nicht?
\item Komplexität: Welche Probleme kann man effizient lösen?
\item Korrektheit: Wie beweist man, dass das Ergebnis richtig ist? \\
      Echtzeit: Dass das richtige Ergebnis rechtzeitig vorliegt.
\item verteilte Systeme: Wie sichert man, dass verteilte Systeme korrekt kommunizieren?
\end{itemize}
\subsubsection{technische Informatik (\textbf{ITE})}
\label{sec-1-1-2}
\begin{itemize}
\item Auf welcher Hardware kann man Programme ausführen, wie baut man dies Hardware?
\item CPU, GPU, RAM, HD, Display, Printer, Networks
\end{itemize}
\subsubsection{praktische Informatik}
\label{sec-1-1-3}
\begin{itemize}
\item Wie entwickelt man Software?
\item Programmiersprachen und Compiler: Wie kommuniziert der Programmierer mit der Hardware?\hfill \textbf{IPI}, \textbf{IPK}
\item Algorithmen und Datenstrukturen: Wie baut man komplexe Programme aus einfachen Grundbausteinen?\hfill \textbf{IAL}
\item Softwaretechnik: Wie organisiert man sehr große Projekte?\hfill \textbf{ISW}
\item Kernanwendung der Informatik: Betriebsysteme, Netzwerke, Parallelisierung\hfill \textbf{IBN}
\begin{itemize}
\item Datenbanksysteme\hfill \textbf{IDB1}
\item Graphik, Graphische Benutzerschnittstellen\hfill \textbf{ICG1}
\item Bild- und Datenanalyse
\item maschinelles Lernen
\item künstliche Intelligenz
\end{itemize}
\end{itemize}
\subsubsection{angewante Informatik}
\label{sec-1-1-4}
\begin{itemize}
\item Wie löst man Probleme aus einem anderem Gebiet mit Programmen?
\item Informationstechnik
\begin{itemize}
\item Buchhandlung, e-commerce, Logistik
\end{itemize}
\item Web programming
\item scientific computing für Physik, Biologie
\item Medizininformatik
\begin{itemize}
\item bildgebende Verfahren
\item digitale Patientenakte
\end{itemize}
\item computer linguistik
\begin{itemize}
\item Sprachverstehen, automatische Übersetzung
\end{itemize}
\item Unterhaltung: Spiele, special effect im Film
\end{itemize}
\section{Wie unterscheidet sich Informatik von anderen Disziplinen?}
\label{sec-2}
\subsection{Mathematik}
\label{sec-2-1}
Am Beispiel der Definition $a \leq b: \exists c \geq 0: a + c = b$ \\
   Informatik: \\
   Lösungsverfahren: $a - b \leq 0$, das kann man leicht ausrechen, wenn man subtrahieren und mit $0$ vergleichen kann. \\
   Quadratwurzel: $y = \sqrt{x} \Leftrightarrow y \geq 0 \wedge y^2 = x (\Rightarrow x > 0)$ \\
   Informatik: Algorithmus aus der Antike: $y = \frac{x}{y}$
iteratives Verfahren: \\
   Initial Guess $y^{(0)} = 1$
schrittweise Verbesserung $y^{(t+1)} = \frac{y^{(t)} + \frac{x}{y^{(t)}}}{2}$
\section{Informatik}
\label{sec-3}
Lösugswege, genauer Algorithmen
\subsection{Algorithmus}
\label{sec-3-1}
\textbf{schematische} Vorgehensweise mit der jedes Problem einer bestimmten \textbf{Klasse} mit \textbf{endliche} vielen \textbf{elementaren} Schritten / Operationen gelöst werden kann
\begin{itemize}
\item schematisch: man kann den Algorithmus ausführen, ohne ihn zu verstehen ($\Rightarrow$ Computer)
\item alle Probleme einer Klasse: zum Beispiel: die Wurzel aus jeder beliebigen nicht-negativen Zahl, und nicht nur $\sqrt{11}$
\item endliche viele Schritte: man kommt nach endlicher Zeit zur Lösung
\item elementare Schrite / Operationen: führen die Lösung auf Operationen oder Teilprobleme zurück, die wir schon gelöst haben
\end{itemize}
\subsection{Daten}
\label{sec-3-2}
Daten sind Symbole,
\begin{itemize}
\item die Entitäten und Eigenschaften der realen Welt im Computer representieren.
\item die interne Zwischenergebnisse eines Algorithmus aufbewahren
\end{itemize}
$\Rightarrow$ Algorithmen transformieren nach bestimmten Regeln die Eingangsdaten (gegebene Symbole) in Ausgangsdaten (Symbole für das Ergebniss).
Die Bedeutung / Interpretation der Symbole ist dem Algorithmus egal $\estimates$ "schematisch"
\subsubsection{Beispiele für Symbole}
\label{sec-3-2-1}
\begin{itemize}
\item Zahlen
\item Buchstaben
\item Icons
\item Verkehrszeichen
\end{itemize}
aber: heutige Computer verstehen nur Binärzahlen $\Rightarrow$ alles andere muss man übersetzen
Eingansdaten: "Ereignisse":
\begin{itemize}
\item Symbol von Festplatte lesen oder per Netzwerk empfangen
\item Benutzerinteraktion (Taste, Maus, \ldots{})
\item Sensor übermittelt Meßergebnis, Stoppuhr läuft ab
\end{itemize}
Ausgangsdaten: "Aktionen":
\begin{itemize}
\item Symbole auf Festplatte schreiben, per Netzwerk senden
\item Benutzeranzeige (Display, Drucker, Ton)
\item Stoppuhr starten
\item Roboteraktion ausführen (zum Beispiel Bremsassistent)
\end{itemize}
Interne Daten:
\begin{itemize}
\item Symbole im Hauptspeicher oder auf Festplatte
\item Stoppuhr starten / Timeout
\end{itemize}
\subsection{Einfachster Computer}
\label{sec-3-3}
endliche Automaten (endliche Zustandsautomaten)
\begin{itemize}
\item befinden sich zu jedem Zeitpunkt in einem bestimmten Zustand aus einer vordefinierten endlichen Zustandsmenge
\item äußere Ereignisse können Zustandsänderungen bewirken und Aktionen auslösen
\end{itemize}
\subsubsection{{\bfseries\sffamily TODO} Graphische Darstellung}
\label{sec-3-3-1}
graphische Darstellung: Zustände = Kreise, Zustandsübergänge: Pfeile
\subsubsection{{\bfseries\sffamily TODO} Darstellung durch Übergangstabellen}
\label{sec-3-3-2}
Zeilen: Zustände, Spalten: Ereignisse, Felder: Aktion und Folgezustände
\begin{center}
\begin{tabular}{llll}
Zustände $\backslash$ Ereignisse & Knopf drücken & Timeout & Timeout(Variante)\\
\hline
aus & $\Rightarrow$\{halb\} \\ \{4 LEDs an\} & \% & ($\Rightarrow$\{aus\},\{nichts\})\\
halb & ($\Rightarrow$\{voll\},\{8 LEDs an\}) & \% & ($\Rightarrow$\{aus\},\{nichts\})\\
voll & ($\Rightarrow$\{blinken an\},\{Timer starten\}) & \% & ($\Rightarrow$\{aus\},\{nichts\})\\
blinken an & ($\Rightarrow$\{aus\},\{Alle LEDs aus, Timer stoppen\}) & ($\Rightarrow$\{blinken aus\},\{alle LEDs aus, Timer starten\}) & ($\Rightarrow$\{blinken aus\},\{8 LEDs aus\})\\
blinken aus & ($\Rightarrow$\{aus\},\{Alle LEDs aus, Timer stoppen\}) & ($\Rightarrow$\{blinken an\},\{alle LEDs an, Timer starten\}) & ($\Rightarrow$\{blinken an\},\{8 LEDs an\})\\
\end{tabular}
\end{center}

Variante: Timer läuft immer (Signal alle 0.3s) $\Rightarrow$ Timout ignorieren im Zustand "aus", "halb", "voll"
\subsubsection{Beispiel 2:}
\label{sec-3-3-3}
\begin{align}
&1~0~1~1~0~1~0 &= 2 + 8 + 16 + 74 &= 90_{\text{dez}} \\
+&0~1~1~1~0~0~1 &= 1 + 8 + 16 + 32 &= 57_{\text{dez}} \\
\hline
1~&0~0~1~0~0~1~1 &= 1 + 2 + 16 + 128 &= 147_{\text{dez}}\checkmark
\end{align}
\paragraph{Implementation mit Endlichen Automaten}
\label{sec-3-3-3-1}
Prinzipen:
\begin{itemize}
\item wir lesen die Eingangsdaten von rechts nach links
\item Beide Zahlen gleich lang (sonst mit 0en auffüllen)
\item Ergebnis wird von rechts nach link ausgegeben
\end{itemize}
\paragraph{{\bfseries\sffamily TODO} Skizze der Automaten}
\label{sec-3-3-3-2}
\begin{center}
\begin{tabular}{lll}
Zustand & Ereignis & Ausgeben\\
\hline
start & (0,1) & "1"\\
start & (1,0) & "1"\\
start & (0,0) & "0"\\
start & (1,1) & "0"\\
carry = 1 & (1,1) & "1"\\
carry = 1 & (0,1) & "0"\\
carry = 1 & (1.0) & "0"\\
carry = 1 & $\emptyset$ & "1"\\
\end{tabular}
\end{center}
\textbf{Wichtig:} In jedem Zustand muss für \textbf{alle möglichen} Ereignisse eine Aktion und Folgezustand definiert werden.
Vergisst man ein Ereignis zeigt der Automat undefiniertes Verhalten, also einen "Bug".
Falls keine sinvolle Reaktion möglich ist: neuer Zustand: "Fehler" $\Rightarrow$ Übergang nach "Fehler",
Aktion: Ausgeben einer Fehlermeldung
\subparagraph{{\bfseries\sffamily TODO} Skizze Fehlermeldung}
\label{sec-3-3-3-2-1}
Ein endlicher Automat hat nur ein Speicherelement, das den aktuelen Zustand angibt. Folge:
\begin{itemize}
\item Automat kann sich nicht merken, wie er in den aktuellen Zustand gekommen ist ("kein Gedächnis")
\item Automat kann nicht beliebig weit zählen, sondern nur bis zu einer vorgegebenen Grenze
\end{itemize}
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm, semithick]
\node[initial,state] (0) {"0"};
\node[state] (1) [right of=0] {"1"};
\node[state] (2) [right of=1]{"2"};
\node[state] (3) [right of=2]{"3"};
\node[accepting,state] [below of=1] (end) {"stop"};
\path (0) edge [loop above] node {"0"} (0)
(0) edge node {"x"} (1)
(0) edge node {$\emptyset$} (end)
(1) edge [loop above] node {"0"} (1)
(1) edge node {"x"} (2)
(1) edge node {$\emptyset$} (end)
(2) edge [loop above] node {"0"} (2)
(2) edge node {"x"} (3)
(2) edge node {$\emptyset$} (end)
(3) edge [loop above] node {"$0\vee x$"} (3)
(3) edge node {"x"} (3)
(3) edge node {$\emptyset$} (end);
\end{tikzpicture}
\end{center}
Insgesamt: Man kann mit endlichen Automaten nur relativ einfache Algorithmen implementieren. (nur reguläre Sprachen)
Spendiert man zusätzlichen Specher, geht mehr:
\begin{itemize}
\item Automat mit Stack-Speicher (Stapel oder Keller) $\Rightarrow$ Kellerautomat (Kontextfreie Sprachen)
\item Automat mit zwei Stacks oder äquivalent Turing-Maschine kann alles auführen, was man intuitiv für berechenbar hält
\end{itemize}
Markov Modelle: endliche Automaten mit probabilistischen Übergangen.
Bisher: Algorithmen für einen bestimmten Zweck (Problemklasse)
Frage: Gibt es einen universellen Algorithms für alle berechenbare Probleme?
Betrache formale Algorithmusbeschreibung als Teil der Eingabe des universellen Algorithmus.
\section{Wie unterscheidet sich Informatik von anderen Disziplinen?}
\label{sec-4}
\subsection{Mathematik}
\label{sec-4-1}
Am Beispiel der Definition $a \leq b: \exists c \geq 0: a + c = b$ \\
   Informatik: \\
   Lösungsverfahren: $a - b \leq 0$, das kann man leicht ausrechen, wenn man subtrahieren und mit $0$ vergleichen kann. \\
   Quadratwurzel: $y = \sqrt{x} \Leftrightarrow y \geq 0 \wedge y^2 = x (\Rightarrow x > 0)$ \\
   Informatik: Algorithmus aus der Antike: $y = \frac{x}{y}$
iteratives Verfahren: \\
   Initial Guess $y^{(0)} = 1$
schrittweise Verbesserung $y^{(t+1)} = \frac{y^{(t)} + \frac{x}{y^{(t)}}}{2}$
\section{Informatik}
\label{sec-5}
Lösugswege, genauer Algorithmen
\subsection{Algorithmus}
\label{sec-5-1}
\textbf{schematische} Vorgehensweise mit der jedes Problem einer bestimmten \textbf{Klasse} mit \textbf{endliche} vielen \textbf{elementaren} Schritten / Operationen gelöst werden kann
\begin{itemize}
\item schematisch: man kann den Algorithmus ausführen, ohne ihn zu verstehen ($\Rightarrow$ Computer)
\item alle Probleme einer Klasse: zum Beispiel: die Wurzel aus jeder beliebigen nicht-negativen Zahl, und nicht nur $\sqrt{11}$
\item endliche viele Schritte: man kommt nach endlicher Zeit zur Lösung
\item elementare Schrite / Operationen: führen die Lösung auf Operationen oder Teilprobleme zurück, die wir schon gelöst haben
\end{itemize}
\subsection{Daten}
\label{sec-5-2}
Daten sind Symbole,
\begin{itemize}
\item die Entitäten und Eigenschaften der realen Welt im Computer representieren.
\item die interne Zwischenergebnisse eines Algorithmus aufbewahren
\end{itemize}
$\Rightarrow$ Algorithmen transformieren nach bestimmten Regeln die Eingangsdaten (gegebene Symbole) in Ausgangsdaten (Symbole für das Ergebniss).
Die Bedeutung / Interpretation der Symbole ist dem Algorithmus egal $\estimates$ "schematisch"
\subsubsection{Beispiele für Symbole}
\label{sec-5-2-1}
\begin{itemize}
\item Zahlen
\item Buchstaben
\item Icons
\item Verkehrszeichen
\end{itemize}
aber: heutige Computer verstehen nur Binärzahlen $\Rightarrow$ alles andere muss man übersetzen
Eingansdaten: "Ereignisse":
\begin{itemize}
\item Symbol von Festplatte lesen oder per Netzwerk empfangen
\item Benutzerinteraktion (Taste, Maus, \ldots{})
\item Sensor übermittelt Meßergebnis, Stoppuhr läuft ab
\end{itemize}
Ausgangsdaten: "Aktionen":
\begin{itemize}
\item Symbole auf Festplatte schreiben, per Netzwerk senden
\item Benutzeranzeige (Display, Drucker, Ton)
\item Stoppuhr starten
\item Roboteraktion ausführen (zum Beispiel Bremsassistent)
\end{itemize}
Interne Daten:
\begin{itemize}
\item Symbole im Hauptspeicher oder auf Festplatte
\item Stoppuhr starten / Timeout
\end{itemize}
\subsection{Einfachster Computer}
\label{sec-5-3}
endliche Automaten (endliche Zustandsautomaten)
\begin{itemize}
\item befinden sich zu jedem Zeitpunkt in einem bestimmten Zustand aus einer vordefinierten endlichen Zustandsmenge
\item äußere Ereignisse können Zustandsänderungen bewirken und Aktionen auslösen
\end{itemize}
\subsubsection{{\bfseries\sffamily TODO} Graphische Darstellung}
\label{sec-5-3-1}
graphische Darstellung: Zustände = Kreise, Zustandsübergänge: Pfeile
\subsubsection{{\bfseries\sffamily TODO} Darstellung durch Übergangstabellen}
\label{sec-5-3-2}
Zeilen: Zustände, Spalten: Ereignisse, Felder: Aktion und Folgezustände
\begin{center}
\begin{tabular}{llll}
Zustände $\backslash$ Ereignisse & Knopf drücken & Timeout & Timeout(Variante)\\
\hline
aus & $\Rightarrow$\{halb\} \\ \{4 LEDs an\} & \% & ($\Rightarrow$\{aus\},\{nichts\})\\
halb & ($\Rightarrow$\{voll\},\{8 LEDs an\}) & \% & ($\Rightarrow$\{aus\},\{nichts\})\\
voll & ($\Rightarrow$\{blinken an\},\{Timer starten\}) & \% & ($\Rightarrow$\{aus\},\{nichts\})\\
blinken an & ($\Rightarrow$\{aus\},\{Alle LEDs aus, Timer stoppen\}) & ($\Rightarrow$\{blinken aus\},\{alle LEDs aus, Timer starten\}) & ($\Rightarrow$\{blinken aus\},\{8 LEDs aus\})\\
blinken aus & ($\Rightarrow$\{aus\},\{Alle LEDs aus, Timer stoppen\}) & ($\Rightarrow$\{blinken an\},\{alle LEDs an, Timer starten\}) & ($\Rightarrow$\{blinken an\},\{8 LEDs an\})\\
\end{tabular}
\end{center}

Variante: Timer läuft immer (Signal alle 0.3s) $\Rightarrow$ Timout ignorieren im Zustand "aus", "halb", "voll"
\subsubsection{Beispiel 2:}
\label{sec-5-3-3}
\begin{align}
&1~0~1~1~0~1~0 &= 2 + 8 + 16 + 74 &= 90_{\text{dez}} \\
+&0~1~1~1~0~0~1 &= 1 + 8 + 16 + 32 &= 57_{\text{dez}} \\
\hline
1~&0~0~1~0~0~1~1 &= 1 + 2 + 16 + 128 &= 147_{\text{dez}}\checkmark
\end{align}
\paragraph{Implementation mit Endlichen Automaten}
\label{sec-5-3-3-1}
Prinzipen:
\begin{itemize}
\item wir lesen die Eingangsdaten von rechts nach links
\item Beide Zahlen gleich lang (sonst mit 0en auffüllen)
\item Ergebnis wird von rechts nach link ausgegeben
\end{itemize}
\paragraph{{\bfseries\sffamily TODO} Skizze der Automaten}
\label{sec-5-3-3-2}
\begin{center}
\begin{tabular}{lll}
Zustand & Ereignis & Ausgeben\\
\hline
start & (0,1) & "1"\\
start & (1,0) & "1"\\
start & (0,0) & "0"\\
start & (1,1) & "0"\\
carry = 1 & (1,1) & "1"\\
carry = 1 & (0,1) & "0"\\
carry = 1 & (1.0) & "0"\\
carry = 1 & $\emptyset$ & "1"\\
\end{tabular}
\end{center}
\textbf{Wichtig:} In jedem Zustand muss für \textbf{alle möglichen} Ereignisse eine Aktion und Folgezustand definiert werden.
Vergisst man ein Ereignis zeigt der Automat undefiniertes Verhalten, also einen "Bug".
Falls keine sinvolle Reaktion möglich ist: neuer Zustand: "Fehler" $\Rightarrow$ Übergang nach "Fehler",
Aktion: Ausgeben einer Fehlermeldung
\subparagraph{{\bfseries\sffamily TODO} Skizze Fehlermeldung}
\label{sec-5-3-3-2-1}
Ein endlicher Automat hat nur ein Speicherelement, das den aktuelen Zustand angibt. Folge:
\begin{itemize}
\item Automat kann sich nicht merken, wie er in den aktuellen Zustand gekommen ist ("kein Gedächnis")
\item Automat kann nicht beliebig weit zählen, sondern nur bis zu einer vorgegebenen Grenze
\end{itemize}
\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm, semithick]
\node[initial,state] (0) {"0"};
\node[state] (1) [right of=0] {"1"};
\node[state] (2) [right of=1]{"2"};
\node[state] (3) [right of=2]{"3"};
\node[accepting,state] [below of=1] (end) {"stop"};
\path (0) edge [loop above] node {"0"} (0)
(0) edge node {"x"} (1)
(0) edge node {$\emptyset$} (end)
(1) edge [loop above] node {"0"} (1)
(1) edge node {"x"} (2)
(1) edge node {$\emptyset$} (end)
(2) edge [loop above] node {"0"} (2)
(2) edge node {"x"} (3)
(2) edge node {$\emptyset$} (end)
(3) edge [loop above] node {"$0\vee x$"} (3)
(3) edge node {"x"} (3)
(3) edge node {$\emptyset$} (end);
\end{tikzpicture}
\end{center}
Insgesamt: Man kann mit endlichen Automaten nur relativ einfache Algorithmen implementieren. (nur reguläre Sprachen)
Spendiert man zusätzlichen Specher, geht mehr:
\begin{itemize}
\item Automat mit Stack-Speicher (Stapel oder Keller) $\Rightarrow$ Kellerautomat (Kontextfreie Sprachen)
\item Automat mit zwei Stacks oder äquivalent Turing-Maschine kann alles auführen, was man intuitiv für berechenbar hält
\end{itemize}
Markov Modelle: endliche Automaten mit probabilistischen Übergangen.
Bisher: Algorithmen für einen bestimmten Zweck (Problemklasse)
Frage: Gibt es einen universellen Algorithms für alle berechenbare Probleme?
Betrache formale Algorithmusbeschreibung als Teil der Eingabe des universellen Algorithmus.
\section{Substitutionsmodell (funktionale Programmierung)}
\label{sec-6}
\begin{itemize}
\item einfaches Modell für arithmetische Berechnung "Taschenrechner"
\item Eingaben und Ausgaben sind Zahlen (ganze oder reelle Zahlen). Zahlenkonstanten heißten "Literale"
\item elementare Funktionen: haben eine oder mehere Zahlen als Argumente (Parameter) und liefern eine Zahl als Ergebnis (wie Mathematik):
\begin{itemize}
\item add(1,2) $\rightarrow$ 3, mul(2,3) $\rightarrow$ 6, analog sub(), div(), mod()
\end{itemize}
\item Funktionsaufrufe können verschachtelt werden, das heißt Argumente kann Ergebnis einer anderen Funktion sein
\begin{itemize}
\item mul(add(1,2),sub(5,3)) $\rightarrow$ 6
\end{itemize}
\end{itemize}
\subsection{Substitutionsmodell}
\label{sec-6-1}
Man kann einen Funktionsaufruf, dessen Argument bekannt ist (das heißt Zahlen sind) durch den Wert des Ergebnisses ersetzen ("substituieren"). Geschachtelte Ausdrücke lassen sich so von innen nach außen auswerten.
\[mul(add(1,2),sub(5,3))\]
\[mul(3,sub(5,3))\]
\[mul(3,2)\]
\[6\]
\begin{itemize}
\item Die arithmetischen Operationene add(), sub(), mul(), div(), mod() werden normalerweise von der Hardware implementiert.
\item Die meisten Programmiersprachen bieten außerdem algebraische Funktionen wie: sqrt(), sin(), cos(), log()
\begin{itemize}
\item sind meist nicht in Hardware, aber vorgefertigte Algorithmen, werden mit Programmiersprachen geliefert, "Standardbibilothek"
\end{itemize}
\item in C++: mathematisches Modul des Standardbibilothek: "cmath"
\item Für Arithmetik gebräuchlicher ist "Infix-Notation" mit Operator-Symbolen "+", "-", "*", "/", "\%"
\item mul(add(1,2),sub(5,3)) $\Leftrightarrow$ ((1+2)*(5-3))
\begin{itemize}
\item oft besser, unter anderem weil man Klammer weglassen darf
\begin{enumerate}
\item "Punkt vor Strichrechnung" 3+4*5 $\Leftrightarrow$ 3+(4*5), mul, div, mod binden stärker als add, sub
\item Operatoren gleicher Präzedenz werden von links nach rechts ausgeführt (links-assoziativ) \\
          1+2+3-4+5 $\Leftrightarrow$ ((((1+2)+3)-4)+5)
\item äußere Klammer kann man weglassen (1+2)$\Leftrightarrow$ 1+2
\end{enumerate}
\end{itemize}
\item Computer wandeln Infix zuerst in Prefix Notation um
\begin{enumerate}
\item weggelassene Klammer wieder einfügen
\item Operatorensymbol durch Funktionsnamen ersetzen und an Prefix-Position verschieben
\[1 + 2 + 3 * 4 / (1 + 5) - 2\]
\[(((1 + 2) + ((3 * 4) / (1 + 5))) - 2)\]
\[sub(add(add(1,2),div(mul(3,4),add(1,5))), 2)\]
\[sub(add(3,div(12,6)), 2)\]
\[sub(add(3,2), 2)\]
\[sub(5, 2)\]
\[2\]
\end{enumerate}
\end{itemize}
\subsection{Bäume}
\label{sec-6-2}
\begin{itemize}
\item bestehen aus Knoten und Kanten (Kreise und Pfeile)
\item Kanten verbinden Knoten mit ihren Kind-knoten
\item jeder Koten (außer der Wurzel) hat genau ein Elternteil ("parent node")
\item Knoten ohne Kinder heißen Blätter ("leaves / leaf node")
\item Teilbaum
\begin{itemize}
\item wähle beliebigen Knoten
\item entferne temporär dessen Elternkante, dadurch wird der Knoten temporär zu einer Wurzel, dieser Knoten mit allen Nachkommen bildet wieder einen Baum (Teilbaum des Orginalbaumes)
\end{itemize}
\item trivialer Teilbaum hat nur einen Knoten
\item Tiefe: Abstand eines Knotens von der Wurzel (Anzahl der Kanten zwischen Knoten und Wurzel)
\begin{itemize}
\item Tiefe des Baums: maximale Tiefe eines Knoten
\end{itemize}
\end{itemize}
\subsubsection{Beispiel}
\label{sec-6-2-1}
\[1 + 2 + 3 * 4 / (1 + 5) - 2\]
\[sub(add(add(1,2),div(mul(3,4),add(1,5))), 2)\]
\begin{center}
\Tree [ .sub [ .add [ .add 1 2 ] [ .div [ .mul 3 4 ] [ .add 1 5 ] ] ] 2 ]
\end{center}
\subsection{Rekursion}
\label{sec-6-3}
Rekursiv $\estimates$ Algorithmus für Teilproblem von vorn.
\subsection{Prefixnotation aus dem Baum rekonstruieren}
\label{sec-6-4}
\begin{enumerate}
\item \label{algstart1} Wenn die Wurzel ein Blatt ist: Drucke die Zahl
\item sonst:
\begin{itemize}
\item Drucke Funktionsnamen
\item Drucke "("
\item Wiederhole den Algorithmus ab \ref{algstart1} für das linke Kind (Teilbaum mit Wurzel = linkes Kind)
\item Drucke ","
\item Wiederhole den Algorithmus ab \ref{algstart1} für das rechte Kind (Teilbaum mit Wurzel = rechtes Kind)
\item Drucke ")"
\end{itemize}
$\Rightarrow$ \[sub(add(add(1,2),div(mul(3,4),add(1,5))), 2)\]
\end{enumerate}
\subsection{Prefixnotation aus dem Baum rekonstruieren}
\label{sec-6-5}
\begin{enumerate}
\item \label{algstart2} Wenn die Wurzel ein Blatt ist: Drucke die Zahl
\item sonst:
\begin{itemize}
\item Drucke Funktionsnamen
\item Drucke "("
\item Wiederhole den Algorithmus ab \ref{algstart2} für das linke Kind (Teilbaum mit Wurzel = linkes Kind)
\item Drucke Operatorsymbol
\item Wiederhole den Algorithmus ab \ref{algstart2} für das rechte Kind (Teilbaum mit Wurzel = rechtes Kind)
\item Drucke ")"
\end{itemize}
$\Rightarrow$ \[sub(add(add(1,2),div(mul(3,4),add(1,5))), 2)\]
\end{enumerate}
$\Rightarrow$ \textbf{inorder}
\subsection{Berechnen des Werts mit Substitutionsmethode}
\label{sec-6-6}
\begin{enumerate}
\item \label{algstart3} Wenn Wurzel dein Blatt gib Zahl zurück
\item sonst:
\begin{itemize}
\item Wiederhole den Algorithmus ab \ref{algstart3} für das linkes Kind (Teilbaum mit Wurzel = rechtes Kind), speichere Ergebnis als "lhs"
\item Wiederhole den Algorithmus ab \ref{algstart3} für das rechte Kind (Teilbaum mit Wurzel = rechtes Kind), speichere Ergebnis als "rhs"
\item berechne funktionsname(lhs,rhs) und gebe das Ergebnis zurück
\end{itemize}
\end{enumerate}
$\Rightarrow$ \textbf{postorder}
\section{Maschienensprachen}
\label{sec-7}
\begin{itemize}
\item optimiert für die Hardware
\item Gegensatz: höhere Programmiersprachen (c++)
\begin{itemize}
\item optimiert für Programmierer
\end{itemize}
\item Compiler oder Interpreter übersetzen Hoch- in Maschinensprache
\end{itemize}
\subsection{Umwandlung in Maschinensprache}
\label{sec-7-1}
\begin{enumerate}
\item Eingaben und (Zwischen)-Ergebnisse werden in Speicherzellen abgespeichert $\Rightarrow$ jeder Knoten im Baum bekommt eine Speicherzelle
\item Speicherzellen für Eingaben initialisieren
\begin{itemize}
\item Notation: SpZ $\leftarrow$ Wert
\end{itemize}
\item Rechenoperationen in Reihenfolge des Substitutionsmodell ausführen und in der jeweiligen Speicherzelle speichern
\begin{itemize}
\item Notation: SpZ-Ergebniss $\leftarrow$ fname SpZArg1 SpZArg2
\end{itemize}
\item alles in Zahlencode umwandeln
\begin{itemize}
\item Funktionsnamen:
\begin{center}
\begin{tabular}{lr}
Opcode & Wert\\
\hline
init & 1\\
add & 2\\
sub & 3\\
mul & 4\\
div & 5\\
\end{tabular}
\end{center}
\end{itemize}
\end{enumerate}
\section{Funktionale Programmierung}
\label{sec-8}
\begin{itemize}
\item bei Maschienensprache werden Zwischenergebnisse in Speicherzellen abgelegt
\item das ist auch in der funktionalen Programmierung eine gute Idee
\item Speicherzellen werden duch Namen (vom Programmierer vergeben) unterschieden
\end{itemize}
\subsection{Beispiel}
\label{sec-8-1}
Lösen einer quadratischen Gleichung:
\[ax^2 + bx + c = 0\]
\[x^2 - 2px + q = 0, p = -\frac{b}{2a},q=\frac{c}{d}\]
\[x_2 = p + \sqrt{p^2 - q},x_2 = p - \sqrt{p^2 - q}\]
ohne Zwischenergebnisse:
\[x_1 \leftarrow add(div(div(b,a),-2),sqrt(sub(mul(div(b,a),-2),div(div(b,a)-1)),div(c,a)))\]
mit Zwischenergebniss und Infix Notation
\[p\leftarrow b / c / -2~\text{oder}~p\leftarrow -0.5 * b / a\]
\[a\leftarrow c / a\]
\[d\leftarrow sqrt(p*p - q)\]
\[x_1\leftarrow p + d\]
\[x_2\leftarrow p - d\]
\subsection{Vorteile von Zwischenergebnissen}
\label{sec-8-2}
\begin{enumerate}
\item lesbarer
\item redundante Berechnung vermieden. Beachte: In der funktionalen Programmierung können die Speicherzellen nach der Initialisierung nicht mehr verändert werden
\item Speicherzellen und Namen sind nützlich um Argumente an Funktionen zu übergeben $\Rightarrow$ Definition eigener Funktionen
\begin{minted}[tabsize=4]{cpp}
function sq(x) {
   return x * x
}
\end{minted}
$\Rightarrow$ $d \leftarrow sqrt(sq(p) - q)$
Speicherzelle mit Namen "x" für das Argument von $sq$
\end{enumerate}
\subsection{Funktionale Programmierung in c++}
\label{sec-8-3}
\begin{itemize}
\item in c++ hat jede Speicherzelle einen Typ (legt Größe und Bedeutung der Speicherzelle fest)
\begin{itemize}
\item wichtige Typen
\begin{center}
\begin{tabular}{ll}
int & ganze Zahlen\\
double & reelle Zahlen\\
std::string & Text\\
\end{tabular}
\end{center}
int: $12,-3$ \\
       double: $-1.02,1.2e-4 = 1.2*10^{-4}$ \\
       std::string: "text"
\end{itemize}
\item Initialisierung wird geschrieben als "typename spzname = Wert;"
\begin{minted}[tabsize=4]{cpp}
double a = ...;
double b = ...;
double c = ...;
double p = -0.5 b / a;
double q = c / a;
double d = std::sqrt(p*p - q);
double x1 = p + d;
double x2 = p - d;
std::cout << "x1: " << x1 << ", x2: " << x2 << std::endl;
\end{minted}
\item eigene Funktionen in C++
\begin{minted}[tabsize=4]{cpp}
// Kommentar (auch /* */)
type_ergebnis fname(type_arg1 name1, ...) {
	// Signatur / Funkitonskopf / Deklaration
	return ergebnis;
	/* Funktionskörper / Definition / Implementation */
}
\end{minted}
\begin{itemize}
\item ganze Zahl quadrieren:
\begin{minted}[tabsize=4]{cpp}
int sq(int x) {
	return x*x;
}
\end{minted}
\item reelle Zahl quadrieren:
\begin{minted}[tabsize=4]{cpp}
double sq(double x) {
	return x*x;
}
\end{minted}
\item beide Varianten dürfen in c++ gleichzeitig definiert sein $\Rightarrow$ "function overloading" $\Rightarrow$ c++ wählt automatisch die richtig Variable anhand des Argumenttypes ("overload resolution")
\begin{minted}[tabsize=4]{cpp}
int x = 2;
double y = 1.1
int x2 = sq(x) // int Variante
double y2 = sq(y) // double Variante
\end{minted}
\item jedes c++-Programm muss genau eine Funktion names "main" haben. Dort beginnt die Programmausführung.
\begin{minted}[tabsize=4]{cpp}
int main() {
	Code;
	return 0;
}
\end{minted}
\begin{itemize}
\item return aus der "main" Funktion ist optional
\end{itemize}
\item Regel von c++ für erlaubte Name
\begin{itemize}
\item erstes Zeichen: Klein- oder Großbuchstaben des englischen Alphabets, oder "\_"
\item optional: weitere Zeichen oder, "\_" oder Ziffer 0-9
\end{itemize}
\item vordefinierte Funktionen:
\begin{itemize}
\item eingebaute $\estimates$ immer vorhanden
\begin{itemize}
\item Infix-Operatoren $+,-,*,/,\%$
\item Prefix-Operatoren $operator+,operator-,\ldots$
\end{itemize}
\item Funktion der Standardbibilothek $\estimates$ müssen "angefordert" werden
\begin{itemize}
\item Namen beginnen mit "std::", "std::sin,\ldots{}"
\item sind in Module geordnet, zum Beispiel
\begin{itemize}
\item cmath $\Rightarrow$ algebraische Funktion
\item complex $\Rightarrow$ komplexe Zahlen
\item string $\Rightarrow$ Zeichenkettenverarbeitung
\end{itemize}
\item um ein Modul zu benutzen muss man zuerst (am Anfang des Programms) sein Inhaltsverzeichnis importieren (Header includieren) $\rightarrow$ include <name>
\begin{minted}[tabsize=4]{cpp}
#include <iostream>
#include <string>
int main() {
	std::cout << "Hello, world!" << std::endl;
	std::string out = "mein erstes Programm\n";
	std::cout << out;
	return 0;
}
\end{minted}
\end{itemize}
\end{itemize}
\item overloading der arithmetischen Operationene
\begin{itemize}
\item overloading genau wie bei $sq$
\begin{itemize}
\item 3 * 4 $\Rightarrow$ int Variante
\item 3.0 * 4.0 $\Rightarrow$ double Variante
\item 3 * 4.0 $\Rightarrow$ automatische Umwandliung in höheren Typ, hier "double" $\Rightarrow$ wird als 3.0 * 4.0 ausgeführt
\end{itemize}
\end{itemize}
\item $\Rightarrow$ Devision unterscheidet sich
\begin{itemize}
\item Integer-Division: 12 / 5 = 2 (wird abgerundet)
\item Double-Division: 12.0 / 5.0 = 2.4
\item -12 / 5 = 2 ($\Rightarrow$ truncated Division)
\item 12.0 / 5.0 = 2.4
\item Gegensatz (zum Beispiel in Python)
\begin{itemize}
\item floor division $\Rightarrow$ wird immer abgerundet $\Rightarrow$ -12 / 4 = -2
\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}
\section{Prozedurale Programmierung}
\label{sec-9}
\subsection{Von der Funktionalen zur prozeduralen Programmierung}
\label{sec-9-1}
\begin{itemize}
\item Eigenschaften der Funktionalen Programmierung:
\begin{itemize}
\item alle Berechnungen durch Funktionsaufruf, Ergebnis ist Rückgabe
\item Ergebnis hängt nur von den Werten der Funktionsargumente ab, nicht von externen Faktoren "referentielle Integrität"
\item Speicherzellen für Zwischenergebnisse und Argumente können nach Initialisierung nicht geändert werden "write once"
\item Möglichkeit rekusiver Funktionsaufrufe (jeder Aufruf bekommt eigene Speicherzellen)
\begin{itemize}
\item Vorteile
\begin{itemize}
\item natürliche Ausdrucksweise für arithmetische und algebraische Funktionaliät ("Taschenrechner")
\item einfache Auswertung durch Substitutionsmodell $\rightarrow$ Auswertungsreihenfolge nach Post-Order
\item mathematisch gut formalisierbar $\Rightarrow$ Korrektheitsbeweise, besonders bei Parallelverarbeitung
\item Rekursion ist mächtig und natürliche für bestimmte Probleme (Fakutlät, Baumtraversierung)
\end{itemize}
\item Nachteile
\begin{itemize}
\item viele Probleme lassen sich anders natürlicher ausdrücken (z.B. Rekursion vs. Iteration)
\item setzt unendlich viel Speicher voraus ($\Rightarrow$ Memory management notwendig $\Rightarrow$ später)
\item Entitäten, die sich zeitlich verändern schwer zu modellieren
\end{itemize}
\item Korrolar: kann keine externen Resourcen (z.B. Konsole, Drucker, \ldots, Bildschirm) ansprechen "keine Seiteneffekte"
\begin{itemize}
\item $\Rightarrow$ Multi-Paradigmen-Sprachen, zum Beispiel Kombination von Funktionaler Programmierung und prozeduraler Programmierung
\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}
\subsection{Kennzeichen}
\label{sec-9-2}
\subsubsection{Prozeduren}
\label{sec-9-2-1}
\begin{itemize}
\item Prozeduren: Funktionen, die nichts zurückgeben, haben nur Seiteneffekte
\begin{itemize}
\item Beispiel
\begin{minted}[tabsize=4]{cpp}
std::cout << "Hello\n"; // Infix
operator<<(std::cout, "Hello\n"; // Prefix
\end{minted}
\item Prozeduren in c++
\begin{enumerate}
\item Funktion die "void" zurückgibt (Pseudotyp für "nichts")
\begin{minted}[tabsize=4]{cpp}
void foo(int x) {
	return;
}
\end{minted}
\item Returnwert ignorieren
\end{enumerate}
\end{itemize}
\end{itemize}
\subsubsection{Steuerung des Programmablaufs}
\label{sec-9-2-2}
\begin{itemize}
\item Anweisungen zur Steuerung des Programmablaufs
\begin{minted}[tabsize=4]{cpp}
if(), else, while(), for()
\end{minted}
\begin{itemize}
\item Funktional
\begin{minted}[tabsize=4]{cpp}
int abs(int x) {
	return (x >= 0) ? x : -x;
}
\end{minted}
\item Prozedural
\begin{minted}[tabsize=4]{cpp}
int abs(int x) {
	if(x >= 0) {
		return x;
	} else {
		return -x;
	}

	// oder
	if(x >= 0) return x;
	return -x;
}
\end{minted}
\end{itemize}
\end{itemize}
\subsubsection{Veränderung von Speicherzellen}
\label{sec-9-2-3}
\begin{itemize}
\item Zuweisung: Speicherzellen können nachträglich verändert werden ("read-write")
\begin{itemize}
\item prozedural:
\begin{minted}[tabsize=4]{cpp}
int foo(int x) {     // x = 3
	int y = 2;
	int z1 = x * y;  // z1 = 6
	y = 5;
	int z2 = z * y;  // z2 = 15
	return z1 + z2;  // 21
}
\end{minted}
\item funktional:
\begin{minted}[tabsize=4]{cpp}
int foo(int x) {     // x = 3
	int y1 = 2;
	int z1 = x * y;  // z1 = 6
	int y2 = 5;
	int z2 = z * y;  // z2 = 15
	return z1 + z2;  // 21
}
\end{minted}
\item Syntax
\begin{minted}[tabsize=4]{cpp}
name = neuer_wert;           // Zuweisung
typ name = neuer_wert;       // Initialisierung
typ const name = neuer_wert; // write once
\end{minted}
\item $\Rightarrow$ Folgen: mächtiger, aber ermöglicht völlig neue Bugs $\Rightarrow$ erhöhte Aufmerksamkeit beim Programmieren
\begin{itemize}
\item die Reihenfolge der Ausführung ist viel kritischer als beim Substitutionsmodell
\item Programmierer muss immer ein mentales Bild des aktuellen Systemzustans haben
\end{itemize}
\end{itemize}
\end{itemize}
\subsubsection{Schleifen}
\label{sec-9-2-4}
Der gleiche Code soll oft wiederholt werden
\begin{minted}[tabsize=4]{cpp}
while(bedingung) {
	// code, wird ausgeführt solange Bedingung "true"
}
\end{minted}
\begin{minted}[tabsize=4]{cpp}
int counter = 0;
while(counter < 3) {
	std::cout << counter << std::endl;
	counter++; // Kurzform für counter = counter + 1
}
\end{minted}
\begin{center}
\begin{tabular}{rlr}
counter & Bedingung & Ausgabe\\
\hline
0 & true & 0\\
1 & true & 1\\
2 & true & 2\\
3 & false & $\emptyset$\\
\end{tabular}
\end{center}

\begin{itemize}
\item in c++ beginnt Zählung meist mit $0$ ("zero based")
\item vergisst man Inkrementierung $\Rightarrow$ Bedingung immer "true" $\Rightarrow$ Endlosschleife $\Rightarrow$ Bug
\item drei äquivalente Schreibweisen für Inkrementierung:
\begin{itemize}
\item counter = counter + 1; // assignment $\estimates$ Zuweisung
\item counter += 1;          // add-assignment $\estimates$ Abbkürzung
\item ++counter;             // pre-increment
\end{itemize}
\end{itemize}
\subsubsection{prozedurale Wurzelberechung}
\label{sec-9-2-5}
\paragraph{Ziel}
\label{sec-9-2-5-1}
\begin{minted}[tabsize=4]{cpp}
double sqrt(double y);
\end{minted}
\paragraph{Methode}
\label{sec-9-2-5-2}
iterative Verbesserung mittel Newtonverfahren
initial$_{\text{guess}}$ $x^{(0)}$ ("geraten"), t = 0 \\
     while not$_{\text{good}}$$_{\text{enough}}$($x^{(t)}$): \\
         update $x^{(t + 1)}$ from $x^{(t)}$ (zum Beispiel $x^{(t + 1)} = x^{(x)} + \Delta^{(t)}$ additives update, $x^{(t + 1)} = x^{(t)}\Delta^{(t)}$ multiplikatives update) \\
         t = t + 1 \\
\subparagraph{Newtonverfahren}
\label{sec-9-2-5-2-1}
Finde Nullstellen einer gegebenen Funktion $f(x)$, das heißt suche $x^\ast$ sodass $f(x^\ast) = 0$ oder $\abs{f(x^\ast)} < \varepsilon$
Taylorreihe von $f(x)$:, $f(x + \Delta) \approx f(x) + f'(x)\Delta +$ setze $x^\ast = x + \Delta$
\[0 \overset{!}{=} f(x^\ast) \approx f(x) + f'(x)\Delta = 0 \Rightarrow \Delta = - \frac{f(x)}{f'(x)}\]
Iteratiosvorschrift:
\[x^{(t + 1)} = x^{(t)} - \frac{f(x^{(\ast)})}{f'(x^{(\ast)})}\]
Anwendung auf Wurzel: setze $f(x) = x^2 - y \Rightarrow$ mit $f(x^\ast) = 0$ gilt
\[(x^\ast)^2 -y = 0 \quad (x^\ast)^2 = y \quad x^\ast = \sqrt{y}\quad f'(x) = 2x)\]
Iterationsvorschrieft:
\[x^{(t + 1)} = x^{(t)} - \frac{(x^{(t)^2}) - y}{2x^{(t)}} = \frac{x^{(t)^2} + y}{2x^{(t)}}\]
\begin{minted}[tabsize=4]{cpp}
double sqrt(double y) {
  if(y < 0.0) {
	  std::cout << "Wurzel aus negativer Zahl\n";
	  return -1.0;
	}
	if(y == 0.0) return 0.0;

	double x = y; // inital guess
	double epsilon = 1e-15 * y;

	while(abs(x * x - y) > epsilon) {
		x = 0.5*(x + y / x);
	}
}
\end{minted}
\subsubsection{for-Schleife}
\label{sec-9-2-6}
\begin{minted}[tabsize=4]{cpp}
int c = 0;
while(c < 3) {
	// unser code
	c++; // vergisst man leicht
}
\end{minted}

Bei der while Schleife kann man leicht vergessen $c$ zu inkrementieren, die for Schleife ist idiotensicher \\
    Äquivalent zu der while Schleife oben ist:
\begin{minted}[tabsize=4]{cpp}
for(int c = 0; c < 3; c++) {
	// unser code
}
\end{minted}

Allgemeine Form:
\begin{minted}[tabsize=4]{cpp}
for(init; Bedingung; Inkrement) {
	// unser code
}
\end{minted}
\begin{itemize}
\item Befehle, um Schleifen vorzeitig abzubrechen
\begin{itemize}
\item continue: Bricht aktuelle Iteration ab und springt zum Scleifenkpf
\item break: bbricht ganz Schleife ab und springt hinter das Schleifenende
\item return: beednet Funktion und auch die Schleife
\end{itemize}
\end{itemize}
Beispiel: nur gerade Zahlen ausgeben
\begin{minted}[tabsize=4]{cpp}
for(int i = 0; i < 10; i++) if(c % 2 == 0) std::cout << c << std::endl;
\end{minted}
Variante mit continue:
\begin{minted}[tabsize=4]{cpp}
for(int i = 0; i < 10; i++) {
	if(c % 2 != 0) continue;
	std::cout << c << std::endl;
}
\end{minted}

\begin{minted}[tabsize=4]{cpp}
for(int i = 0; i < 10; i += 2) {
	std::cout << c << std::endl;
}
\end{minted}
\begin{minted}[tabsize=4]{cpp}
double sqrt(double y) {
	while(true) {
		x = (x + y / 2) / 2.0;
		if(abs(x * x - y) < epsilon) {
			return x;
		}
	}
}
\end{minted}
\section{Datentypen}
\label{sec-10}
\subsection{Basistypen}
\label{sec-10-1}
Bestandteil der Sprachsyntax und normalerweise direkt von der Hardware unterstützt (CPU)
\begin{itemize}
\item int, double, bool ($\Rightarrow$ später mehr)
\end{itemize}
\subsection{zusammengesetzte Typen}
\label{sec-10-2}
mit Hilfe von "struct" oder "class" aus einfachen Typen zusammengesetzt
\begin{itemize}
\item wie das geht $\Rightarrow$ später
\item Standardtypen: in der C++ Standardbibilothek definiert, aktivire durch $\#include <module_name>$
\begin{itemize}
\item std::string, std::complex, etc.
\end{itemize}
\item externe Typen: aus anderer Bibilothek, die manzuvor herunterladen und installieren muss
\item eigene Typen: vom Programmierer selbst implementiert $\Rightarrow$ später
\end{itemize}
Durch "objekt-orientierte Programmierung" ($\Rightarrow$ später) erreicht man, dass zusammengesetzte Typen genauso einfach und bequem und effizient sind wie Basistypen (nur c++, nicht c)
\begin{itemize}
\item "Kapselung": die interne Struktur und Implementation ist für Benutzer unsichtbar
\item Benutzer manipuliert Speicher über Funktionen ("member functions") $\estimates$ Schnittstelle des Typs, "Interface", API
\end{itemize}

$\Rightarrow$ Punktsyntax: type$_{\text{name}}$ t = init; t.foo(a1, a2); $\estimates$ foo(t, a1, a2);
\subsection{Zeichenketten-Strings:}
\label{sec-10-3}
zwei Datentypen in c++
\begin{itemize}
\item klassischer c-string: char[] ("charakter array") $\Rightarrow$ nicht gekapselt, umständlich
\item c++ string: std::string gekapselt und bequem (nur dieser in der Vorlesung)
\item string literale: "zeichekette", einzelnes Zeichen: 'z' ("z" = Kette der Länge 1) \\
     Vorsicht: die String-Literale sind c-strings (gibt keine c++ string-Literale), müssen erst in c++ strings umgewandelt werden, das passiert mist automatisch
\begin{itemize}
\item \#include <string>
\item Initialisierung:
\begin{minted}[tabsize=4]{cpp}
std::string s = "abcde";
std::string s2 = s1;
std::string leer = "";
std::string leer(); // Abkürzung, default constructor
\end{minted}
\item Länge
\begin{minted}[tabsize=4]{cpp}
s.size();
assert(s.size() == 5);
assert(leer.size() == 0);
s.empty() // Abkürzung für s.size() == 0
\end{minted}
\item Zuweisung
\begin{minted}[tabsize=4]{cpp}
s = "xy";
s2 = leer;
\end{minted}
\item Addition
Aneinanderkettung von String ("concatenate")
\begin{minted}[tabsize=4]{cpp}
std::string s3 = s + "ijh"; // "xyijh"
s3 = "ghi" + s; // "ghixy"
s3 = s + s; // "xyxy"
// aber nicht!!
s3 = "abc" + "def"; // Bug literale unterstütze + mit ganz anderer Bedeutung
s3 = std::string("abc") + "def"; // Ok
\end{minted}
\item Add-Assignment: Abkürzung für Addition gefolt von Zuweisung
\begin{minted}[tabsize=4]{cpp}
s += "nmk"; // s = s + "nmk" => "xynmk"
\end{minted}
\item die Zeichen werden intern in einem C-Array gespeichert (Array = "Feld") \\
       Array: zusammenhängende Folge von Speicherzellen des gleichen Typs, hier 'char' (für einzelne Zeichen), Die Länge wird (bei std::string) automatisch angepasst, die einzelnen Speicherzellen sind durchnummerriert
in c++: von $0$ beginnend $\estimates$ Index
\begin{itemize}
\item Indexoperator:
\begin{minted}[tabsize=4]{cpp}
s[index]; // gibt das Zeichen an Position "index" zurück
\end{minted}
Anwendung: jedes Zeichen einzeln ausgeben
\begin{minted}[tabsize=4]{cpp}
std::string s = "abcde";

for(int i = 0; i < s.size(); i++) {
	std::cout << s[i] << std::endl;
}
\end{minted}
String umkehren
\begin{minted}[tabsize=4]{cpp}
int i = 0; // Anfang des Strings
int k = s.size() - 1; // Ende des String
while(i < k) {
	char tmp = s[i];
	s[i] = s[k];
	s[k] = tmp;
	i++; k--;
}
\end{minted}
Variante 2: neuen String erzeugen
\begin{minted}[tabsize=4]{cpp}
std::string s = "abcde";
std::string r = "";
for(int i = s.size() - 1; i >= 0; i--) {
	r += s[i];
}
\end{minted}
\end{itemize}
\end{itemize}
\end{itemize}
\section{Umgebungsmodell}
\label{sec-11}
Gegenstück zum Substitutionsmodell (in der funktionalen Programmierung) für die prozedurale Programmierung
\begin{itemize}
\item Regeln für Auswertung von Audrücken
\item Regeln für automatische Speicherverwaltung
\begin{itemize}
\item Freigeben nicht mehr benötigter Speicherzellen, $\Rightarrow$ bessere Approximation von "unendlich viel Speicher"
\end{itemize}
\item Umgebung beginnt normalerweise bei "\{" und endet bei "\}" \\
    Ausnahmen:
\begin{itemize}
\item $for$: Umgebung beginnt schon bei "for" $\Rightarrow$ Laufvariable ist Teil der Umgebung
\item Funktionsdefinitionen: Umgebung beginnt beim Funktionskopf $\Rightarrow$ Speicherzellen fpr Argumente und Ergebnis gehören zur Umgebung
\item globale Umgebung außerhalb aller "\{ \}" klammern
\end{itemize}
\item automatische Speiccherverwaltung
\begin{itemize}
\item Speicherzellen, die in einer Umgebung angelegt werde (initialisiert, deklariert) werde, am Ende der Umgebung in umgekehrter Reihenfolge freigegeben
\item Computer fügt vor "\}" automatisch die Notwendigen Befehle ein
\item Speicherzellen in der globalen Umgebung werden am Programmende freigegeben
\begin{minted}[tabsize=4]{cpp}
- int global = 1;
  int main() {
	  int l = 2;
	  {
		  int m = 3
	  } // <- m wird freigegeben
  } // <- l wird freigegeben
  // <- global wird freigegeben
\end{minted}
\end{itemize}
\item Umgebungen können beliebig geschachtelt werden $\Rightarrow$ alle Umgebungen bilden einen Baum, mit der globalen Umgebung als Wurzel
\item Funktionen sind in der globalen Umgebung definiert
\begin{itemize}
\item Umgebung jeder Funktion sind Kindknoten der globalen Umgebung (Ausnahme: Namensräume $\Rightarrow$ siehe unten) \\
      $\Rightarrow$ Funktions Umgebung ist \textbf{nicht} in der Umgebung, wo die Funktion aufgerufen wird
\end{itemize}
\item Jede Umgebung besitzt eine \textbf{Zuordungstabelle} für alle Speicherzellen, die in der Umgebung definiert wurden
\begin{center}
\begin{tabular}{llr}
Name & Typ & aktueller Wert\\
\hline
l & int & 2\\
\end{tabular}
\end{center}
\item jeder Name kann pro Umgebung nur einmal vorkommen
\item Ausnahme Funktionsnamen können mehrmals vorkommen bei function overloading (nur c++)
\item Alle Befehle werden relativ zur aktuellen Umgebung ausgeführt
\begin{itemize}
\item aktuell: Zuordungstabelle der gleichen Umgebung und aktueller Wert zum Zeitpunkt des Aufrufs \\
      Beispiel: $c = a * b;$ \\
      Regeln:
\item wird der Name (nur $a, b, c$) in der aktuellen Zuordungstabelle gefunden
\begin{enumerate}
\item Typprüfung $\Rightarrow$ Fehlermeldung, wenn Typ und Operation nicht zusammenpassen
\item andernfalls, setze aktuellen Wert aus Tabelle in Ausdruch ein (ähnlich Substitutionsmodell)
\end{enumerate}
\item wird Name nicht gefunden: suche in der Elternumgebung weiter
\item wir der Name bis zur Wurzel (gloable Umgebung) nicht gefunden $\Rightarrow$ Fehlermeldung
\item $\Rightarrow$ ist der Nme in mehreren Umgebungen vorhanden gild as zerst gefundene (Typ, Wert)
\end{itemize}
\item $\Rightarrow$ Programmierrer muss selbst darauf achten, ass
\begin{enumerate}
\item bei der Suche die gewünschte Spicherzelle gefunden wird $\Rightarrow$ beutze "sprechende Namen"
\item der aktuelle Wert der richtig ist $\Rightarrow$ beachte Reihenfolge der Befehle!
\end{enumerate}
\item Namensraum: spezielle Umgebungen in der globalen Umgebung (auch geschachtelt) mit einem Namen \\
    Ziele:
\begin{itemize}
\item Gruppieren ovn Funktionalität in Module (zusätzlich zu Headern)
\item verhinderung von Namenskollisionen
\end{itemize}
Beispiel: c++ Standardbibilothek:
\begin{minted}[tabsize=4]{cpp}
namespace std {
double sqrt(double x);
namespace chrono {
class system_clock;
}
}

// Benutzung mit Namespace-Prefix:
std::sqrt(80);
std::chrono::system_clock clock;
\end{minted}
 Besonderheit: mehrere Blöcke mit selbem Namensraum werden verschmolzen
Beispiel
\begin{minted}[tabsize=4]{cpp}
int p = 2;
int q = 3;

int foo(int p) {
	return p * q;
}

int main() {
	int k = p * q; // beides global => 6 = 2 * 3
	int p = 4; // lokales p verdeckt globales p
	int r = p * q; // p lokal, q global => 12 = 4 * 3
	int s = foo(p); // lokale p von main() wird zum lokalen p von foo() 12 = 4 * 3
	int t = foo(q); // globales q wird zum lokalen p von foo() 9 = 3 * 3
	int q = 5;
	int n = foo(g); // lokales q wird zum lokalen p von foo() 15 = 5 * 3
}
\end{minted}
\end{itemize}
\section{Referenzen}
\label{sec-12}
sind neue (zusätzliche) Namen für vorhandene Speicherzellen
\begin{minted}[tabsize=4]{cpp}
int x = 3; // neue Variable x mit neuer Speicherzell
int & y = x; // Referenz: y ist neuer Name für x, beide haben die selbe Speicherzelle
y = 4; // Zuweisung an y, aber x ändert sich auch, das heißt x == 4
x = 5; // jetzt y == 5
int const & z = x; // read-only Referenz, das heißt z = 6 ist verboten
x = 6; // jetzt auch z == 6
\end{minted}
Hauptanwendung:
\begin{itemize}
\item die Umgebung, wo eine Funktion aufgerufen wird und die Umgebung der Implementation sind unabhängig, das heißt Variablen der einen Umgebung sind in der anderen nicht sichtbar
\item häuftig möchte man Speicherzellen in beidel Umgebungen teilen $\Rightarrow$ verwende Referenzen
\item häufig will man vermeiden, dass eine Variable kopiert wird (pass-by-value)
\begin{itemize}
\item Durch pass-by-reference brauch man keine Kopie $\Rightarrow$ typisch "const \&", also read-only, keine Seiteneffekte
\begin{minted}[tabsize=4]{cpp}
int foo(int x) { // pass-by-value
	x += 3;
	return x;
}

int var(int & y) { // pass-by-reference
	y += 3; // Seiteneffekt der Funktion
	return y;
}

void baz(int & z) { // pass-by-reference
	z += 3;
}

int main() {
	int a = 3;
	std::cout << foo(a) << std::endl; // 5
	std::cout << a << std::endl; // 2
	std::cout << bar(a) << std::endl; // 5
	std::cout << a << std::endl; // 5
	baz(a);
	std::cout << a << std::endl; // 8
}
\end{minted}
in der funktionalen Programmierungt sind Seiteneffekte grundsätzlich verboten, mit Ausnahmen, zum Beispiel für Ein-/Ausgabe
\end{itemize}
\end{itemize}
\section{Container-Datentypen}
\label{sec-13}
Dienen dazu, andere Daten aufzubewahren
\begin{itemize}
\item Art der Elemente:
\begin{itemize}
\item homogene Container: alle Elemente haben gleichen Type (typisch für c++)
\item heterogene Container: Elemente könne verschiedene Typen haben (z.B. Python)
\end{itemize}
\item nach Größen
\begin{itemize}
\item statische Container: feste Größe, zur Compilezeit bekannt
\item dynamische Container: Größe zur Laufzeit veränderbar
\end{itemize}
\item Arrays sind die wichtigsten Container, weil effizient auf Hardware abgebildet und einfach zu benutzen
\begin{itemize}
\item klassisch: Arrays sind statisch, zum Beispiel C-Arrays (hat c++ geerbt)
\begin{minted}[tabsize=4]{cpp}
int a[20];
\end{minted}
\item modern: dynamische Arrays
\begin{itemize}
\item Entdeckung einer effizienten Implementation
\item Kapselung durch objekt-orientierte Programmierung (sonst zu kompliziert)
\end{itemize}
\end{itemize}
\item wir kennen bereits ein dynamisches Array: std::string ist Abbildung int (Index) $\rightarrow$ char (Zeichen), mit $0 \leq~\text{index}~ < ~\text{s.size()}$
\begin{itemize}
\item wichtigste Funktion: s.size() (weil Größe dynamisch), s[4 ] Indexzugriff, s+="mehr" Zeichen anhängen
\end{itemize}
\item wir wollen das selbe Verhalten für beliebige Elementtypen:
\begin{minted}[tabsize=4]{cpp}
#include <vector>

//          Elementtyp    Größe  Initialwert der Elemente
std::vector<double    > v(20   ,           0.0           );
// analog
std::vector<int>;
std::vector<std::string>;
\end{minted}
\item weitere Verallgemeinerung: Indextyp beliebig (man sagt dann "Schlüssel-Typ") "assoziatives Array"
\begin{itemize}
\item typische Fälle:
\begin{itemize}
\item Index ist nicht im Bereich (0,size], zum Beispiel Matrikelnummern
\item Index ist string, zum Beispiel Name eines Studenten
\begin{minted}[tabsize=4]{cpp}
#include <map>
#include <unordered_map>

// Binärer Suchbaum
std::map;

// Hashtabelle, siehe Algorithmen und Datenstrukturen
std::unordered_map;

//       Schlüsseltyp  Elementtyp
std::map<int         , double> noten; noten[3121101] = 10;
std::map<std::string, double> noten; noten["krause"] = 10;
\end{minted}
\item Indexoperationen wie beim Array
\item Elemente werden beim 1. Zugriff automatisch erzeugt (dynamisch)
\end{itemize}
\end{itemize}
\item alle dynamischen und assoziativen Arrays unterstützen a.size() zum Abfragen der Grlße
\end{itemize}
\subsection{std::vector}
\label{sec-13-1}
\begin{itemize}
\item Erzeugen:
\begin{minted}[tabsize=4]{cpp}
std::vector<double> v(20, 1.0);
std::vector<double> v; // leeres Array
std::vector<double> v = {1.0, -3.0, 2.2}; // "initializer list": Element für Anfangszustand
\end{minted}
\item Größe:
\begin{minted}[tabsize=4]{cpp}
v.size();
v.empty(); // => v.size() == 0
\end{minted}
\item Größe ändern
\begin{minted}[tabsize=4]{cpp}
v.resize(neue_groesse, initialwert);
// Dann:
// Fall 1: neue_groesse < size(): Element ab Index "neue_groesse" gelöscht die andern bleiben
// Fall 2: neue_groesse > size(): neue Elemente mit Initialwert am Ende anhängen, die anderen bleiben
// Fall 3: neue_groesse == size(): nichts passiert

v.push_back(neues_element); // ein neues Element am Ende anhängen (ähnlich string += "mehr")
v.insert(v.begin() + index, neues_element); // neues element an Position "index" einfügen 0 <= index <= size()
// Falls index == size(): am Ende anhängen, sonst: alte Elemente ab Index werden eine Position nach hinten verschoben (teuer)

v.pop_back(); // letzes Element löschen (effizient)
v.erase(v.begin() + index); // Element an Pos index löschen, alles dahinter eine Position verschieben (teuer)
v.clear(); // alles löschen
\end{minted}
\item Zugriff
\begin{minted}[tabsize=4]{cpp}
v[k]; // Element bei Index k
v.at(k); // wie v[k], aber Fehlermeldung, wenn nicht 0 <= k < size() (zum Debuggen)
\end{minted}
\item Funktionen für Container benutzen in c++ immer Iteratoren, damit sie für verschiedene Container funktionieren
\begin{itemize}
\item Iterator-Range
\begin{minted}[tabsize=4]{cpp}
// erstes Element
v.begin()

// hinter letztem Element
v.end()
\end{minted}
\item im Header <algorithm>
\item alle Elemente kopieren
\begin{minted}[tabsize=4]{cpp}
std::vector<double> source = {1.0, 2, 3, 4, 5};
std::vector<double> target(source.size(), 0.0);
std::copy(source.begin(), source.end(), target.begin());
std::copy(source.begin() + 2, source.end() - 1, target.begin()); // nur index 2 .. size() - 1 kopieren
\end{minted}
\item Elemente sortieren
\begin{minted}[tabsize=4]{cpp}
std::sort(v.begin(), v.end()); // "in-place" sortieren
\end{minted}
\item Elemente mischen:
\begin{minted}[tabsize=4]{cpp}
std::random_shuffle(v.begin(), v.end()); // "in-place" mischen
\end{minted}
\end{itemize}
\end{itemize}
\subsubsection{Effizenz von push$_{\text{back}}$}
\label{sec-13-1-1}
Warum ist push$_{\text{back}}$() effizient? (bei std::vector)
\begin{itemize}
\item veraltete Lehrmeinung: Arrays sind nur effizient wenn statisch (das heißt Größe zur Compilezeit, oder spätestens vei Initialisierung, bekannt)
\begin{itemize}
\item sonst: andere Datenstruktur verwenden, zum Beispiel verkettete Liste (std::list)
\end{itemize}
\item modern: bei vielen Anwendungen genügt, wenn Array (meist) nur am Ende vergrößert wird (zum Beispiel push$_{\text{back}}$())
\begin{itemize}
\item dies kann sehr effizient unterstützt werden $\Rightarrow$ dynamisches Array
\end{itemize}
\item std::vector verwaltet intern ein statisches Array der Größe "capacity", v.capacity() >= c.size()
\begin{itemize}
\item wird das interne Array zu klein $\Rightarrow$ wird automatisch auf ein doppelt so großes umgeschaltet
\item ist das interne Array zu groß, bleiben unbenutzt Specherzellen als Reserve
\end{itemize}
\item Verhalten bei push$_{\text{back}}$():
\begin{enumerate}
\item nach REserve vorhanden: lege neues Element im eine unbenutze Speicherzelle $\Rightarrow$ billig
\item keine Reserve
\begin{enumerate}
\item alloziiere neues statisches Array mit doppeler Kapazität
\item kipiere die Daten aus altem ins neue Array
\item gebe das alte Array frei
\item gehe zum Anfang des Algorithmus, jetzt wieder Reserve vorhanden
\end{enumerate}
\end{enumerate}
\item das Umkopieren ist nicht zu teuer, weil es nur selten notwendig ist
\item Bespiel:
\begin{minted}[tabsize=4]{cpp}
std::vector<int> v;

for(int i = 0; i < 32; i++) v.push_back(k);
\end{minted}
\begin{center}
\begin{tabular}{rrrrrr}
k & capacity vor push$_{\text{back}}$() & capacity nach push$_{\text{back}}$() & size() & Reserve & \#Umkopieren\\
\hline
0 & 0 & 1 & 1 & 0 & 0\\
1 & 1 & 2 & 2 & 0 & 1\\
\hline
2 & 2 & 4 & 3 & 1 & 2\\
3 & 4 & 4 & 4 & 0 & 2\\
\hline
4 & 4 & 8 & 5 & 3 & 4\\
5-7 & 8 & 8 & 8 & 0 & 0\\
\hline
8 & 8 & 16 & 9 & 7 & 8\\
9-15 & 16 & 16 & 16 & 0 & 0\\
\hline
16 & 16 & 32 & 17 & 15 & 16\\
17-31 & 32 & 32 & 32 & 0 & 0\\
\end{tabular}
\end{center}
\begin{itemize}
\item was kostet das:
\begin{itemize}
\item 32 Elemente einfügen = 32 Kopien extern $\Rightarrow$ intern
\item aus allem Array ins neu kopieren $(1 + 2 + 4 + 8 + 16) = 31$ kopieren intern $\Rightarrow$ intern
\item $\Rightarrow$ im Durchschnitt sind pro Einfügung 2 Kopien nötig
\item $\Rightarrow$ dynamisches Array ist doppel so teuer sie das statische  $\Rightarrow$ immer noch sehr effizient
\end{itemize}
\end{itemize}
\item relevante Funktionen von std::vector
\begin{minted}[tabsize=4]{cpp}
v.size() // aktuelle Zahl der Elemente
v.capacity() // aktuelle Zahl Speicherzellen
assert(v.capacity() - v.size() >= 0) // Reserve
v.resize(new_size) // ändert immer v.size(), aber v.capacity() nur wenn < new_size
v.reserve(new_capacity) // änder v.size() nicht, aber v.capacity() falls new_capacity >= size
v.shrink_to_fit() // == v.reserve/v.size()) Reseve ist danach 0, wenn Endgröße erreicht
\end{minted}
\item wenn Reserve > size: capacity kann auch halbiert werden
\item wichtige Container der c++ Standardbibilothek
\item wir hatten dynamische Arrays std::string, std::vector, assozaitive Arrays std::map, std::unordered$_{\text{map}}$
\item std::set, std::unordered$_{\text{set}}$: Menge, jedes Element ist hächstens einmal enthalten zum Beispiel Duplikate
\item std::stack (Stapel, Keller): unterstützt push und pop() mit Last in- First out Semantik (LIFO) äquivalent zu push$_{\text{back}}$() und pop$_{\text{back}}$() bei std::vector
\item std::queue (Warteschlange) push() und pop() mit First in-first out Semantik (FIFO)
\item std::deque ("double-ended queue") gleichzeitig stack und queue, puhs, pop$_{\text{front}}$(), pop$_{\text{back}}$()
\item std::priority$_{\text{queue}}$, push() und pop() - Element mit höchster niedrigster Priorität (unser defined)
\end{itemize}
\section{Iteratoren}
\label{sec-14}
\begin{itemize}
\item für Arrays lautet kanonische Schleife
\begin{minted}[tabsize=4]{cpp}
for(int i = 0; i != v.size(); i++) {
	int current = v[i]; // lesen
	v[i] = new_value; // schreiben
}
\end{minted}
\item wir wollen eine so einfache Schleife für beliebige Container
\begin{itemize}
\item der Index-Zugriff v[] ist bei den meisten Container nicht effizient
\item Iteratoren sind immer effizient $\Rightarrow$ es gibt sie in allen modernen Programmiersprachen, aber Details sehr unterschiedlich
\item Analogie: Zeiger einer Ühr, Cursor in Textverarbeitung
\begin{itemize}
\item $\Rightarrow$ ein Iterator zeigt immer auf ein Element des Containers, oder auf Spezialwert "ungültiges Element"
\end{itemize}
\item in c++ unerstützt jeder Iterator 5 Grundoperationen
\begin{enumerate}
\item Iterator auf erstes Element erzeugen: auto iter = v.begin();
\item Iterator auf "ungültiges Element" erzeugen: auto end = v.end();
\item Vergleich iter1 \texttt{= iter2 (Zeigen auf gleiches Element), iter !} end: iter zeigt \textbf{nicht} auf ungültiges Element
\item zum nächsten weitergehen: ++iter. Ergebnis ist v.end(), wenn man vorher beim letzten Element war
\item auf Daten zugreifen: *iter ("Dereferenzierung") analog v[k]
\end{enumerate}
kanonische Schleife:
\begin{minted}[tabsize=4]{cpp}
for(auto iter = v.begin(); iter != v.end(); ++iter) {
int current = *iter; // lesen
*iter = new_value; // schreiben
}
// Abkürzung: range-based for loop
for(auto & element : v) {
int current = element; // lesen
element  = new_vlaue; // schreiben
}
\end{minted}
\end{itemize}
\item Iteratoren mit den 5 Grundoperationen heißen "forward iterator" (wegen ++iter)
\item "bidirectional iterators": unterstützen auch --iter, zum vorigen Element ((fast) alle Iteratoren in std)
\item "random acces iterators": beliebige Sprünge "iter += 5; iter -= 3;"
\item Besonderheit für assoziative Arrays (std::map, std::unordered$_{\text{map}}$)
Schlüssel und Werte können beliebig gewählt werden
\begin{itemize}
\item $\Rightarrow$ das aktuelle Element ist ein Schlüssel / Wert -Paar, das heißt Iterator gibt Schlüssel und Wert zurück
\begin{minted}[tabsize=4]{cpp}
(*iter).first; // Schlüssel
(*iter).second; // Wert
// Abkürzung
iter->first;
iter->second;
\end{minted}
\begin{itemize}
\item bei std::map liefern die Iteratoren die Elemente in aufsteigneder Reihenfolge der Schlüssel
\end{itemize}
\end{itemize}
\item Die Funktion std::transform()
\begin{itemize}
\item wir hatten: std::copy()
\begin{minted}[tabsize=4]{cpp}
std::vector<double> source = {1, 2, 3, 4};
std::vector<double> target(source.size());
std::copy(source.begin(), source.end(), target.begin());
\end{minted}
\item std::transform:
\begin{minted}[tabsize=4]{cpp}
// nach Kleinbuchstaben konvertieren
std::string source = "aAbCdE";
std::string target = source;
std::transform(source.begin(), source.end(), target.begin(), std::tolower); // Name einer Funktion, die ein einzelnes Element transformiert, t="aabcde"
// die Daten quadrieren
double sq(double x) { return x * x; }
std::transform(source.begin(), source.end(), target.begin(), sq); // target == {1, 4, 9, 16}
// das ist eine Abkürzung für eine Schleife
auto src_begin = source.begin();
auto src_end = source.end();
auto tgt_begin = target.begin();

for(; src_begin != src_end; src_begin++, tgt_begin++) {
	*tgt_begin = sq(*src_begin);
}
\end{minted}
\begin{itemize}
\item Der Argumenttyp der Funktion muss mit dem source Elementtyp kompatibel sein. Der Returntyp der Funktion muss mit dem Target-Elementtyp kompatibel sein.
\item Das letzte Argument von std::transform() muss ein Funktor sein (verhält sich wie eine Funktion), drei Varianten:
\begin{enumerate}
\item normale Funktion, z.B. sq. Aber: wenn Funktion für mehrere Argumenttypen überladen ist (overloading) (zum Beispiel, wenn es sq(double) und sq(int) gibt), muss der Programmierer dem Compiler sagen, welche Version gemeint ist $\Rightarrow$ für Fortgeschrittene ("functionpointer cast")
\item Funktorobjekte $\Rightarrow$ objekt-orientierte Programmierung
\item Definiere eine namenlose Funktion $\Rightarrow$ "Lambda-Funktion $\lambda$"
\begin{itemize}
\item statt $\lambda$ verwenden wir den Universalnamen []
\begin{minted}[tabsize=4]{cpp}
std::transform(source.begin(), source.end(), target.begin(), [](double x) { return x*x; }); // statt Funktionsname sq wie bei 1 steht hier die ganz Funktionsimplementation
// Returntyp setzt Computer automatisch ein, wenn es nur einen return-Befehl gibt.
\end{minted}
\item Lambda-Funktionen können noch viel mehr $\Rightarrow$ für Fortgeschrittene
\item std::transform() kann in-place arbeiten (das heißt source-Container überschreiben), wenn source und target gleich
\begin{minted}[tabsize=4]{cpp}
std::transform(source.begin(), source.end(), source.begin(), sq);
\end{minted}
\end{itemize}
\end{enumerate}
\item Die Funktion std::sort() zum in-place sortieren eines Arrays
\begin{minted}[tabsize=4]{cpp}
std::vector<double> v = {4, 2, 3, 5 ,1};
std::sort(v.begin(), v.end()); // v == {1, 2, 3, 4, 5}
\end{minted}
\item std::sort ruft intern den $<$-Operator des Elementtyps auf, um Reihenfolge zu bestimmen
\item die $<$-Operation muss eine totale Ordung der Elemente definieren:
\begin{itemize}
\item $a < b$ muss für beliebige $a,b$ ausführbar sein
\item transitiv: $(a < b) \wedge (b < c) \Rightarrow (a < c)$
\item anti-symmetrisch: $!(a < b) \wedge !(b < a) \Rightarrow a == b$
\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}

\section{Insertion Sort}
\label{sec-15}
schnellster Sortieralgorithmus für kleine Arrays ($n\leq 30$) hängt von Compiler und CPU ab
\begin{itemize}
\item Idee von Insertion Sort:
\begin{itemize}
\item wie beim Aufnehmen und Ordnen eines Kartenblatts
\item gegeben: bereits sortierte Teilmenge bis Position $k - 1$ Karten bereits in Fächer
\item Einfügen des k-ten Elements an richtiger Stelle $\rightarrow$ Erzeuge Lücke an richtiger Positin duch verschieben von Elementen nach rechts
\item Wiederholung für $k = 1, \ldots, N$
\item Bespiel:
\begin{center}
\begin{tabular}{rrrrr}
4 & 2 & 3 & 5 & 1\\
\hline
4 & \_ & 3 & 5 & 1\\
\_ & 4 & 3 & 5 & 1\\
2 & 4 & 3 & 5 & 1\\
\hline
2 & 4 & \_ & 5 & 1\\
2 & \_ & 4 & 5 & 1\\
2 & 3 & 4 & 5 & 1\\
\hline
2 & 3 & 4 & \_ & 1\\
2 & 3 & 4 & 5 & 1\\
\hline
2 & 3 & 4 & 5 & \_\\
\_ & 2 & 3 & 4 & 5\\
1 & 2 & 3 & 4 & 5\\
\end{tabular}
\end{center}
\begin{minted}[tabsize=4]{cpp}
void insertion_sort(std::vector<double> & v) {
	for(int i = 0; i < v.size(); i++) {
		double current = v[i];
		int j = i; // Anfangsposition der Lücke
		while(j > 0) {
			if(v[j - 1] < current) { // -> if(cmp(a, b))
				break; // j ist richtige Position der Lücke
			}
			v[j] = v[j - 1];
			j--;
		}
		v[j] = current;
	}
}
\end{minted}
\item andere Sortierung: definiere Funktor cmp(a, b), der das gewüschte kleiner realisiert (gibt genau dann "true" zurück, wenn a "kleiner" b nach neuer Sortierung)
\item neue Sortierung am besten per Lambda-Funktion an std::sort übergeben
\begin{minted}[tabsize=4]{cpp}
std::sort(v.begin(), v.end()); // Standartsort mit "<"
std::sort(v.begin(), v.end(), [](double a, double b) { return a < b; }); // Standardsortierung aufsteigen
std::sort(v.begin(), v.end(), [](double a, double b) { return b < a; }); // absteigende Sortierung
std::sort(v.begin(), v.end(), [](double a, double b) { return std::abs(a) < std::abs(b); }); // Normal nach Betrag; // Normal nach Betrag
std::sort(v.begin(), v.end(), [](std::string a, std::string b) {
	std::transform(a.begin(), a.end(), a.begin(), std::tolower);
	std::transform(b.begin(), b.end(), b.begin(), std::tolower);
	return a < b;
});
\end{minted}
\end{itemize}
\end{itemize}
\section{generische Programmierung}
\label{sec-16}
insertion$_{\text{sort}}$ soll für beliebige Elementtypen funktionieren
\begin{minted}[tabsize=4]{cpp}
template<typename T>
void insertion_sort(std::vector<T> & v) {
	for(int i = 0; i < v.size(); i++) {
		T current = v[i];
		int j = i; // Anfangsposition der Lücke
		while(j > 0) {
			if(v[j - 1] < current) { // -> if(cmp(a, b))
				break; // j ist richtige Position der Lücke
			}
			v[j] = v[j - 1];
			j--;
		}
		v[j] = current;
	}
}
\end{minted}
\begin{itemize}
\item Ziel: benutze template-Mechanismus, damit \textbf{eine} Implementation für viele verschiedene Typen verwendbar ist
\begin{itemize}
\item erweitert funktionale und prozedurale und objekt-orientiere Programmierung
\end{itemize}
\item zwei Arten von Templates ("Schablone"):
\begin{enumerate}
\item Klassen-templates für Datenstrukturen, zum Beispiel Container sollen beliebige Elementtypen unterstützen
\begin{itemize}
\item Implementation $\Rightarrow$ später
\item Benutzung: Datenstrukturname gefolgt vom Elementtyp in Spizen Klammern (std::vector<double>), oder mehrere Typen, zum Beispiel Schlüssel und Wert bei std::map<std::string, double>
\end{itemize}
\item Funktionen-Templates: es gab schon function overloadingg
\begin{minted}[tabsize=4]{cpp}
int sq(int x) {
	return x * x;
}

double sq(double x) {
   return x * x;
}

// und so weiter für komplexe und rationale Zahlen...
\end{minted}
\begin{itemize}
\item Nachteil
\begin{itemize}
\item wenn die Implementationen gleich sind $\rightarrow$ nutzlose Arbeit
\item Redundanz ist gefährlich: korrigiert man einen Bug wir leicht eine Variante vergessen
\end{itemize}
\item mit templates reicht eine Implementation
\begin{minted}[tabsize=4]{cpp}
template<typename T> // T: Platzhalter für beliebigen Typ, wird später durch einen tatsächlichen Typ ersetzt
T sq(T x) {
	return x * x; // implizierte Anforderung an den Typ T, er muss Multiplikation unterstützen, sonst: Fehlermeldung
}
\end{minted}
\begin{itemize}
\item wie bei Substituieren von Variablen mit Werten, aber jetzt mit Typen
\item Benutzug:
\begin{itemize}
\item Typen für die Platzhalter hinter dem Funktionsnamen in spitzen klammern
\begin{minted}[tabsize=4]{cpp}
sq<int>(2) == 4;
sq<double>(3.0) == 9.0,
\end{minted}
\item meist kann man die Typangabe <type> weglassen, weil der Computer sie anhand des Argumenttyps automatisch einsetzt:
\begin{minted}[tabsize=4]{cpp}
sq(2); // == sq<int>(2) == 4
sq(3.0); // == sq<double>(3.0) == 9
\end{minted}
\item kombiniert man templates mit Overloading, wird die ausprogrammierte Variante vom Compiler bevorzugt.
Komplizierte Fälle (Argument teilweise Template, teilweise hard$_{\text{coded}}$) $\Rightarrow$ für Fortgeschrittene
\end{itemize}
\item Beispiel 2: Funktion, die ein Array auf Konsole ausgibt, für beliebige Elementtypen
\begin{minted}[tabsize=4]{cpp}
template<typename ElementType>
void print_vector(std::vector<ElementType> const & v) {
	std::cout << "{";
	if(v.size() > 0) {
		std::cout << " " << v[0];
		for(int i = 1; i < v.size(); i++) {
			std::cout << ", " << v[i];
		}
	}
	std::cout << " }";
}
\end{minted}
\item Verallgemeinerung für beliebige Container mittel Iteratoren:
\begin{minted}[tabsize=4]{cpp}
std::list<int> l = {1, 2, 3};
print_containter(l.begin(), l.end()); // "{1,2,3}"
\end{minted}
\item es genügen forward$_{\text{interators}}$
\begin{minted}[tabsize=4]{cpp}
Iterator iter2 = iter1; // Kopie erzeugen
iter1++; // zum nächsten Element
iter1 == iter2; // Zeigen sie auf das selbe Element?
iter1 != end;
*iter1; // Zugrif auf aktuelles Element

template<typename Iterator>
void print_container(Iterator begin, Iterator end) {
	std::cout << "{}";
	if(begin != end) { // Container nicht leer?
		std::cout << " " << *begin++;
		for(;begin != end; begin++) {
			std::cout << ", " << *begin;
		}
	std::cout << "}";
}
\end{minted}
\item Bespiel 3: checken, ob Container sortiert ist
\begin{minted}[tabsize=4]{cpp}
template<typename E, typename CMP>
bool check_sorted(std::vector<E> const & v, CMP less_than) {
	for(int i = 1; i < v.size(); i++) {
		if(less_than(v[k], v[k - 1])) { // statt v[k] < v[k - 1], ausnutzen der Transitivität
			return false;
		}
	}
	return true;
}

// Aufruf:
std::vector<double> v = {1.0, 2.0, 3.0};
check_sorted(v, [](double a, double b) { return a < b; } ); // == true

check_sorted(v, [](double a, double b) { return a > b; } ); // == false

// implementation für iteratoren
template<typename Iterator, typename CMP>
bool check_sorted(Iterator begin, Iterator end, CMP less_than) {
	if(begin == end) {
		return true;
	}
	Iterator next = begin;
	++next;
	for(; next != end; ++begin, ++next) {
		if(less_than(*next, *begin)) {
			return false;
		}
	}
	return true;
}
// == std::is_sorted
\end{minted}
\item Bemerkung1: Complier-Fehlermeldungen bei Template-Code sind oft schwer zu interpretieren, $\Rightarrow$ Erfahrug nötig aber: Compiler werden darin immer besser, besonders clang-comiler
\item mit Templatees kann man noch viel raffiniertere Dinge machen, zum Beispiel Traits-Klassen, intelligent libraries template meta programming $\Rightarrow$ nur für Fortgeschrittene
\end{itemize}
\end{itemize}
\end{enumerate}
\end{itemize}
% Emacs 25.1.1 (Org mode 8.2.10)
\end{document}